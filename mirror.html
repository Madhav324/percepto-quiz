<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVI Fixation Mirror Assessment</title>
    <!-- face-api.js for eye tracking -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 15px;
        }

        .container {
            text-align: center;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 650px;
            padding: 20px;
            position: relative;
        }

        /* Header and profile styles */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        h1 {
            font-size: 22px;
            color: #333;
            margin: 0;
        }
        
        h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }
        
        /* Profile Icon */
        .profile-icon {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .profile-icon:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .patient-indicator {
            display: inline-block;
            background-color: #e9f5e9;
            color: #4CAF50;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }

        /* Camera container */
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 0;
            padding-bottom: 75%; /* 4:3 aspect ratio */
            margin: 0 auto 20px;
            overflow: hidden;
            border-radius: 8px;
        }

        #camera {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        /* Mirror frames */
        .mirror-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            border: 15px solid;
            border-radius: 8px;
        }

        .classic-mirror {
            border-color: #c0c0c0;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }

        .led-mirror {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.8), inset 0 0 10px rgba(255,255,255,0.5);
        }

        .toy-mirror {
            border-color: #ff9800;
            border-style: dashed;
            box-shadow: inset 0 0 10px rgba(255,152,0,0.5);
        }

        /* Light stimulus */
        .light-stimulus {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,0,0.9) 50%, rgba(255,200,0,0.7) 100%);
            box-shadow: 0 0 20px rgba(255,255,0,0.9), 0 0 40px rgba(255,200,0,0.5);
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.3s ease;
            opacity: 0;
        }
        
        .light-stimulus.active {
            opacity: 1;
            animation: pulse-glow 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255,255,0,0.9), 0 0 40px rgba(255,200,0,0.5);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(255,255,0,1), 0 0 60px rgba(255,200,0,0.7);
                transform: scale(1.1);
            }
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #333;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        button {
            padding: 8px 15px;
            border: none;
            background-color: #4CAF50;
            color: white;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        button.active {
            background-color: #ff9800;
        }

        /* Observation checklist */
        .observation-container {
            margin-top: 20px;
            text-align: left;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }

        .observation-container h3 {
            font-size: 16px;
            margin-bottom: 10px;
        }

        .observation-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .observation-item input[type="checkbox"] {
            margin-right: 10px;
        }

        /* Report container */
        #report-container {
            margin-top: 40px;
            width: 100%;
            max-width: 600px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* Enhanced report styles */
        .attempt-details {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            width: 100%;
        }
        
        .detail-section {
            margin-top: 10px;
            padding: 8px;
            background-color: #f0f7f0;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }
        
        .detail-section h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #2e7d32;
        }
        
        .highlight-row {
            font-weight: bold;
        }
        
        .attempt-details .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            padding: 2px 5px;
        }
        
        .detail-section-header {
            background-color: #f0f8ff;
            padding: 6px 5px;
            margin-top: 8px;
            margin-bottom: 6px;
            border-radius: 4px;
            font-weight: bold;
            color: #2c3e50;
            display: block !important;
            text-align: center;
        }
        
        .detail-section-header span {
            width: 100%;
        }
        
        /* Eye tracking overlay */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
        }
        
        .detection-data {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 20;
            max-width: 250px;
        }
        
        .eye-track-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            align-items: center;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .toggle-switch label {
            font-size: 12px;
            cursor: pointer;
        }

        /* Responsive styles */
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            .camera-container {
                padding-bottom: 100%; /* Square aspect ratio on mobile */
            }
            
            .mirror-frame {
                border-width: 10px;
            }
            
            .button-group {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CVI Fixation Mirror Assessment</h1>
            <div class="profile-icon" id="profileIcon" title="Back to Home" onclick="window.location.href='index.html'"></div>
        </div>
        
        <div id="patientIndicator" class="patient-indicator" style="display: none;">Patient Assessment</div>
        
        <div class="camera-container">
            <video id="camera" autoplay playsinline></video>
            <div id="mirrorFrame" class="mirror-frame classic-mirror"></div>
            <div id="lightStimulus" class="light-stimulus"></div>
            <canvas id="overlay"></canvas>
            <div class="detection-data" id="detectionData">Eye tracking initializing...</div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="pattern">Pursuit Test:</label>
                <select id="pattern">
                    <option value="horizontal">Horizontal Line (Left to Right)</option>
                    <option value="vertical">Vertical Line (Up and Down)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="speed">Speed:</label>
                <input type="range" id="speed" min="1" max="10" value="5">
            </div>
            
            <div class="control-group">
                <label for="frameStyle">Mirror Style:</label>
                <select id="frameStyle">
                    <option value="classic-mirror">Classic Silver</option>
                    <option value="led-mirror">LED Lights</option>
                    <option value="toy-mirror">Toy Theme</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="startBtn">Start Stimulus</button>
                <button id="stopBtn">Stop</button>
                <button id="pauseBtn">Pause</button>
                <button id="reverseBtn">Reverse</button>
                <button id="homeBtn" onclick="window.location.href='index.html'">Home</button>
            </div>
            
            <div class="eye-track-controls">
                <div class="toggle-switch">
                    <input type="checkbox" id="enableEyeTracking" checked>
                    <label for="enableEyeTracking">Enable Eye Tracking</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="showTrackingVisuals" checked>
                    <label for="showTrackingVisuals">Show Tracking Visuals</label>
                </div>
            </div>
        </div>
        
        <div class="observation-container">
            <h3>Assessment Checklist</h3>
            <div class="observation-section">
                <h4>Assessment Results</h4>
                <div style="padding: 15px; background: #f9f9f9; border-radius: 5px; margin-bottom: 15px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <small style="color: #666;">Fixation Duration</small><br>
                            <strong id="autoFixationValue" style="font-size: 20px; color: #2196F3;">0.0s</strong>
                        </div>
                        <div>
                            <small style="color: #666;">Gaze Movements</small><br>
                            <strong id="autoMovementValue" style="font-size: 20px; color: #2196F3;">0</strong>
                        </div>
                    </div>
                    <div style="margin-top: 10px;">
                        <small style="color: #666;">Pursuit Quality</small><br>
                        <strong id="autoPursuitValue" style="font-size: 20px; color: #2196F3;">--</strong>
                    </div>
                </div>
            </div>
            
            <div class="observation-section">
                <h4>Clinical Notes</h4>
                <div class="observation-item">
                    <label for="fixationDuration">Observed Fixation (seconds):</label>
                    <input type="number" id="fixationDuration" min="0" max="300" value="0">
                    <small style="display: block; margin-top: 3px; color: #666;">Use 0 to save automated value</small>
                </div>
                <div class="observation-item" style="margin-top: 10px;">
                    <label for="pursuitCount">Pursuit Attempts (0-5):</label>
                    <select id="pursuitCount">
                        <option value="0">Use automated</option>
                        <option value="1">1/5</option>
                        <option value="2">2/5</option>
                        <option value="3">3/5</option>
                        <option value="4">4/5</option>
                        <option value="5">5/5</option>
                    </select>
                </div>
            </div>
            <div class="observation-item">
                <label for="notes">Notes:</label>
                <textarea id="notes" rows="3" style="width: 100%;"></textarea>
            </div>
            <div class="button-group">
                <button id="saveBtn">Save Observations</button>
            </div>
        </div>
        
        <div id="report-container">
            <h2>Previous Assessments</h2>
            <ul id="report-list"></ul>
            <button id="clear-report" onclick="clearReport()">Clear Reports</button>
        </div>
    </div>

    <!-- Firebase App (the core Firebase SDK) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <!-- Firebase Auth -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <!-- Firebase Database -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDFENL5Z_2Cewh4p6zp_BZtxL9n0di-9u8",
            authDomain: "projeccvi.firebaseapp.com",
            projectId: "projeccvi",
            storageBucket: "projeccvi.appspot.com",
            messagingSenderId: "198292153802",
            appId: "1:198292153802:web:7d7be38e3721fdea613064",
            measurementId: "G-82VHYJEHFN"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();
        
        // Check if we're in a doctor-patient context
        const isPatientQuiz = sessionStorage.getItem('currentPatientId') !== null;
        const currentPatientId = sessionStorage.getItem('currentPatientId');
        const doctorId = sessionStorage.getItem('doctorId');
        
        console.log('Quiz context in Mirror:', { 
            isPatientQuiz, 
            currentPatientId: currentPatientId || 'none',
            doctorId: doctorId || 'none'
        });

        // Camera variables
        let camera = document.getElementById('camera');
        let cameraStream = null;
        
        // Light stimulus variables
        let lightStimulus = document.getElementById('lightStimulus');
        let animationId = null;
        let isRunning = false;
        let isPaused = false;
        let isReversed = false;
        let speed = 5;
        let pattern = 'horizontal'; // Fixed: Changed from 'linear' to 'horizontal' to match dropdown options
        let xPos = 0;
        let yPos = 0;
        let angle = 0;
        
        // Assessment data
        let startTime = 0;
        let assessmentDuration = 0;
        let pausedTime = 0;
        let pauseStartTime = 0;
        let interactionCount = 0;
        let firstTapTime = 0;
        let hasRecordedFirstTap = false;
        
        // Final captured values (frozen when stopped)
        let finalFixationDuration = 0;
        let finalFollowingScore = 0;
        let finalPursuitQuality = 'Not Started';
        
        // Eye tracking variables
        let isFaceDetectionInitialized = false;
        let enableEyeTracking = true;
        let showTrackingVisuals = true;
        let detectionInterval;
        let eyeMovementData = [];
        let lastEyePosition = { x: 0, y: 0 };
        
        // Eyeball tracking with smoothing buffers
        let lastEyeballVector = { x: 0, y: 0 };
        let eyeballVectorHistory = [];
        const EYEBALL_HISTORY_SIZE = 5; // Store recent history for smoothing
        
        let lastFacePosition = { x: 0, y: 0 };
        let eyeMovementCount = 0;
        let eyeballMovementCount = 0;
        let eyeFixationCount = 0;
        let eyeFixationDuration = 0;
        let lastDetectionTime = 0;
        let detectionFrameCount = 0;
        let frameRate = 0;
        
        // Light following variables
        let isFollowingLight = false;
        let followingScore = 0;
        let followingHistory = [];
        const FOLLOWING_HISTORY_SIZE = 15; // Increased window for more stable following detection
        let lightPosition = { x: 0, y: 0 };
        let lastLightPosition = { x: 0, y: 0 };
        
        // Calibration variables - clinically appropriate thresholds
        let isCalibrated = false;
        let calibrationPoints = [];
        let maxEyeballMovement = 5.0; // Based on typical gaze redirections
        let eyeballNoiseThreshold = 0.8; // Filters noise, detects real movements

        // Auth state observer
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                console.log('User authenticated in Mirror:', user.uid);
                
                try {
                    // Check if user is a doctor
                    if (!isPatientQuiz) {
                        const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                        const role = roleSnapshot.val();
                        
                        if (role === 'doctor') {
                            console.log('Doctor authenticated');
                            // Check if we're in doctor-patient context
                            if (currentPatientId && doctorId) {
                                console.log(`Doctor ${doctorId} viewing patient ${currentPatientId}`);
                                // Display patient indicator
                                document.getElementById('patientIndicator').style.display = 'inline-block';
                                
                                // Get patient profile
                                const patientSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/profile`).once('value');
                                profile = patientSnapshot.val();
                            } else {
                                console.log('Doctor viewing their own quiz');
                                // Get doctor profile
                                const doctorSnapshot = await database.ref(`doctors/${user.uid}/profile`).once('value');
                                profile = doctorSnapshot.val();
                            }
                        } else {
                            // Regular user
                            console.log('Loading user profile in Mirror');
                            const userSnapshot = await database.ref(`users/${user.uid}/profile`).once('value');
                            profile = userSnapshot.val();
                        }
                    } else {
                        // Patient context
                        document.getElementById('patientIndicator').style.display = 'inline-block';
                        const patientSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/profile`).once('value');
                        profile = patientSnapshot.val();
                    }
                    
                    // Set profile initial
                    let initial = 'U';
                    if (profile && profile.name) {
                        initial = profile.name.charAt(0).toUpperCase();
                    } else if (user.email) {
                        initial = user.email.charAt(0).toUpperCase();
                    }
                    
                    document.getElementById('profileIcon').textContent = initial;
                    
                    // Initialize camera
                    initCamera();
                    
                    // Initialize button states
                    updateButtonStates();
                    
                    // Load previous assessments
                    loadPreviousAssessments();
                    
                } catch (error) {
                    console.error('Error initializing:', error);
                }
            } else {
                // Not logged in, redirect to login
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                if (!currentPatientId) {
                    window.location.href = 'login.html';
                }
            }
        });
        
        // Initialize camera
        async function initCamera() {
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                camera.srcObject = cameraStream;
                console.log('Camera initialized successfully');
                
                // Initialize face detection after camera is ready
                camera.addEventListener('loadeddata', initFaceDetection);
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Could not access camera. Please check your camera permissions.');
            }
        }
        
        // Initialize face detection models
        async function initFaceDetection() {
            if (isFaceDetectionInitialized) return;
            
            try {
                document.getElementById('detectionData').textContent = 'Loading face detection models...';
                
                // Load required models for face and landmark detection
                await faceapi.nets.tinyFaceDetector.loadFromUri('https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights');
                await faceapi.nets.faceLandmark68Net.loadFromUri('https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights');
                
                // Add face expression model for better landmark fitting
                await faceapi.nets.faceExpressionNet.loadFromUri('https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights');
                
                console.log('Face detection models loaded successfully');
                document.getElementById('detectionData').textContent = 'Face detection ready';
                
                isFaceDetectionInitialized = true;
                
                // Start eye tracking if enabled
                if (enableEyeTracking) {
                    startEyeTracking();
                }
            } catch (error) {
                console.error('Error initializing face detection:', error);
                document.getElementById('detectionData').textContent = 'Error loading detection models';
            }
        }
        
        // Event listeners for controls
        document.getElementById('pattern').addEventListener('change', function() {
            pattern = this.value;
            interactionCount++;
            recordFirstTap();
            if (isRunning && !isPaused) {
                stopAnimation();
                startAnimation();
            }
        });
        
        document.getElementById('speed').addEventListener('input', function() {
            speed = parseInt(this.value);
            interactionCount++;
            recordFirstTap();
        });
        
        document.getElementById('frameStyle').addEventListener('change', function() {
            const mirrorFrame = document.getElementById('mirrorFrame');
            // Remove all classes
            mirrorFrame.classList.remove('classic-mirror', 'led-mirror', 'toy-mirror');
            // Add selected class
            mirrorFrame.classList.add(this.value);
            interactionCount++;
            recordFirstTap();
        });
        
        // Eye tracking toggle controls
        document.getElementById('enableEyeTracking').addEventListener('change', function() {
            enableEyeTracking = this.checked;
            if (enableEyeTracking) {
                startEyeTracking();
            } else {
                stopEyeTracking();
            }
        });
        
        document.getElementById('showTrackingVisuals').addEventListener('change', function() {
            showTrackingVisuals = this.checked;
            const overlay = document.getElementById('overlay');
            overlay.style.display = showTrackingVisuals ? 'block' : 'none';
        });
        
        document.getElementById('startBtn').addEventListener('click', function() {
            startAssessment();
            interactionCount++;
        });
        
        document.getElementById('stopBtn').addEventListener('click', function() {
            stopAssessment();
            interactionCount++;
        });
        
        document.getElementById('pauseBtn').addEventListener('click', function() {
            togglePause();
            interactionCount++;
        });
        
        document.getElementById('reverseBtn').addEventListener('click', function() {
            toggleReverse();
            interactionCount++;
        });
        
        document.getElementById('saveBtn').addEventListener('click', function() {
            saveAssessment();
        });
        
        // Track first tap on observation form inputs
        document.getElementById('fixationDuration').addEventListener('input', recordFirstTap);
        document.getElementById('pursuitCount').addEventListener('change', recordFirstTap);
        document.getElementById('notes').addEventListener('input', recordFirstTap);
        
        // Record first tap time
        function recordFirstTap() {
            if (!hasRecordedFirstTap && startTime > 0) {
                firstTapTime = (Date.now() - startTime - pausedTime) / 1000;
                hasRecordedFirstTap = true;
                console.log('First tap recorded:', firstTapTime, 'seconds');
            }
        }
        
        // Start assessment
        function startAssessment() {
            if (!isRunning) {
                startTime = Date.now();
                pausedTime = 0;
                hasRecordedFirstTap = false;
                
                // Reset final captured values
                finalFixationDuration = 0;
                finalFollowingScore = 0;
                finalPursuitQuality = 'Running...';
                
                startAnimation();
                isRunning = true;
                isPaused = false;
                updateButtonStates();
                
                // Initialize displays
                updateAssessmentDisplays(false);
            }
        }
        
        // Stop assessment
        function stopAssessment() {
            if (isRunning) {
                stopAnimation();
                isRunning = false;
                isPaused = false;
                // Calculate actual duration excluding paused time
                assessmentDuration = (Date.now() - startTime - pausedTime) / 1000; // in seconds
                
                // CAPTURE FINAL VALUES - freeze assessment metrics from ENTIRE assessment
                finalFixationDuration = eyeFixationDuration;
                finalFollowingScore = followingScore;
                
                // Calculate final pursuit quality based on ENTIRE assessment
                if (followingScore > 0.7 && assessmentDuration > 5) {
                    finalPursuitQuality = 'Excellent';
                } else if (followingScore > 0.5 && assessmentDuration > 3) {
                    finalPursuitQuality = 'Good';
                } else if (followingScore > 0.3 && assessmentDuration > 2) {
                    finalPursuitQuality = 'Fair';
                } else if (followingScore > 0.1) {
                    finalPursuitQuality = 'Poor';
                } else {
                    finalPursuitQuality = 'Very Poor';
                }
                
                // Update displays with final cumulative values
                updateAssessmentDisplays(true);
                
                updateButtonStates();
            }
        }
        
        // Toggle pause
        function togglePause() {
            if (isRunning) {
                if (isPaused) {
                    // Resume - add paused duration to total
                    pausedTime += Date.now() - pauseStartTime;
                    startAnimation();
                    isPaused = false;
                    document.getElementById('pauseBtn').textContent = 'Pause';
                } else {
                    // Pause - record pause start time
                    pauseStartTime = Date.now();
                    stopAnimation();
                    isPaused = true;
                    document.getElementById('pauseBtn').textContent = 'Resume';
                }
                updateButtonStates();
            }
        }
        
        // Toggle direction
        function toggleReverse() {
            isReversed = !isReversed;
            if (isRunning && !isPaused) {
                // No need to restart animation, just reverse direction
            }
        }
        
        // Update button states based on assessment status
        function updateButtonStates() {
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const reverseBtn = document.getElementById('reverseBtn');
            
            if (isRunning) {
                startBtn.disabled = true;
                stopBtn.disabled = false;
                pauseBtn.disabled = false;
                reverseBtn.disabled = false;
                stopBtn.classList.add('active');
            } else {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                pauseBtn.disabled = true;
                reverseBtn.disabled = true;
                stopBtn.classList.remove('active');
                pauseBtn.textContent = 'Pause';
            }
        }
        
        // Animation functions
        function startAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Initialize position based on container size
            const containerWidth = lightStimulus.parentElement.offsetWidth;
            const containerHeight = lightStimulus.parentElement.offsetHeight;
            const stimulusWidth = lightStimulus.offsetWidth;
            const stimulusHeight = lightStimulus.offsetHeight;
            
            const maxX = containerWidth - stimulusWidth;
            const maxY = containerHeight - stimulusHeight;
            
            // Start from the left-center or top-center depending on pattern
            if (pattern === 'horizontal') {
                xPos = 0;
                yPos = maxY / 2;
            } else if (pattern === 'vertical') {
                xPos = maxX / 2;
                yPos = 0;
            }
            
            // Reset direction
            isReversed = false;
            
            // Add active class for visual feedback
            lightStimulus.classList.add('active');
            
            animateStimulus();
        }
        
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            // Remove active class when stopped
            lightStimulus.classList.remove('active');
        }
        
        function animateStimulus() {
            const containerWidth = lightStimulus.parentElement.offsetWidth;
            const containerHeight = lightStimulus.parentElement.offsetHeight;
            const stimulusWidth = lightStimulus.offsetWidth;
            const stimulusHeight = lightStimulus.offsetHeight;
            
            const maxX = containerWidth - stimulusWidth;
            const maxY = containerHeight - stimulusHeight;
            
            // Calculate speed factor (1-10 scale) - optimized for smoother movement
            const speedFactor = speed * 0.5;
            
            // Two pursuit patterns: horizontal and vertical
            switch(pattern) {
                case 'horizontal':
                    // Horizontal movement (left to right)
                    if (!isReversed) {
                        xPos += speedFactor;
                        if (xPos > maxX) {
                            xPos = maxX;
                            isReversed = true;
                        }
                        // Keep vertical position centered
                        yPos = maxY / 2;
                    } else {
                        xPos -= speedFactor;
                        if (xPos < 0) {
                            xPos = 0;
                            isReversed = false;
                        }
                        // Keep vertical position centered
                        yPos = maxY / 2;
                    }
                    break;
                    
                case 'vertical':
                    // Vertical movement (up and down)
                    if (!isReversed) {
                        yPos += speedFactor;
                        if (yPos > maxY) {
                            yPos = maxY;
                            isReversed = true;
                        }
                        // Keep horizontal position centered
                        xPos = maxX / 2;
                    } else {
                        yPos -= speedFactor;
                        if (yPos < 0) {
                            yPos = 0;
                            isReversed = false;
                        }
                        // Keep horizontal position centered
                        xPos = maxX / 2;
                    }
                    break;
            }
            
            // Update light position with sub-pixel accuracy for smoother animation
            lightStimulus.style.left = `${Math.round(xPos * 10) / 10}px`;
            lightStimulus.style.top = `${Math.round(yPos * 10) / 10}px`;
            
            // Store light position for eye tracking correlation
            lightPosition = { x: xPos, y: yPos };
            
            // Continue animation
            animationId = requestAnimationFrame(animateStimulus);
        }
        
        // Save assessment results
        async function saveAssessment() {
            const user = auth.currentUser;
            if (!user) {
                alert('You need to be logged in to save assessment results.');
                return;
            }
            
            if (!isRunning && assessmentDuration === 0) {
                alert('You need to run an assessment before saving results.');
                return;
            }
            
            // Stop assessment if still running
            if (isRunning) {
                stopAssessment();
            }
            
            try {
                // Get observation data
                const manualFixationDuration = parseInt(document.getElementById('fixationDuration').value) || 0;
                const manualPursuitCount = parseInt(document.getElementById('pursuitCount').value) || 0;
                const notes = document.getElementById('notes').value;
                
                // Use manual values if provided (non-zero), otherwise use CAPTURED final values
                const savedFixationDuration = manualFixationDuration > 0 ? manualFixationDuration : Math.round(finalFixationDuration);
                
                // Convert pursuit quality to count if not manually overridden
                let savedPursuitCount = manualPursuitCount;
                if (manualPursuitCount === 0 && enableEyeTracking) {
                    // Auto-convert FINAL captured quality score to count
                    if (finalFollowingScore > 0.8) savedPursuitCount = 5;
                    else if (finalFollowingScore > 0.7) savedPursuitCount = 4;
                    else if (finalFollowingScore > 0.5) savedPursuitCount = 3;
                    else if (finalFollowingScore > 0.3) savedPursuitCount = 2;
                    else if (finalFollowingScore > 0.15) savedPursuitCount = 1;
                    else savedPursuitCount = 0;
                }
                
                // Prepare data object as a flat structure without nested objects
                const timestamp = Date.now();
                const assessmentData = {
                    timestamp,
                    assessmentDuration,
                    interactionCount,
                    firstTapTime: firstTapTime || 0,
                    pattern,
                    speed,
                    // Mirror fixation data (auto or manual)
                    fixationDuration: savedFixationDuration,
                    fixationDurationSource: manualFixationDuration > 0 ? 'manual' : 'auto',
                    // Pursuit test data (auto or manual)
                    pursuitCount: savedPursuitCount,
                    pursuitCountSource: manualPursuitCount > 0 ? 'manual' : 'auto',
                    pursuitSuccessRate: (savedPursuitCount / 5) * 100,
                    notes: notes,
                    // Eye tracking data if enabled (using captured final values)
                    eyeTrackingEnabled: enableEyeTracking,
                    faceMovementCount: eyeMovementCount || 0,
                    eyeballMovementCount: eyeballMovementCount || 0,
                    eyeFixationDuration: finalFixationDuration || 0,
                    followingLightScore: finalFollowingScore || 0,
                    pursuitQuality: finalPursuitQuality,
                    // Store simplified movement data
                    eyeMovements: eyeMovementData ? eyeMovementData.length : 0
                };
                
                // Determine the correct path based on user role
                let path;
                
                // Check if this is a patient assessment (doctor viewing patient)
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                const doctorId = sessionStorage.getItem('doctorId');
                
                if (currentPatientId && doctorId) {
                    // This is a doctor testing a patient
                    console.log(`Saving patient assessment results - Doctor: ${doctorId}, Patient: ${currentPatientId}`);
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/mirror/${timestamp}`;
                } else {
                    // Regular user assessment
                    // Check if user is a doctor
                    const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                    const role = roleSnapshot.val();
                    
                    if (role === 'doctor') {
                        console.log(`Saving doctor's own assessment results: ${user.uid}`);
                        path = `doctors/${user.uid}/quiz/mirror/${timestamp}`;
                    } else {
                        console.log(`Saving regular user assessment results: ${user.uid}`);
                        path = `users/${user.uid}/quiz/mirror/${timestamp}`;
                    }
                }
                
                console.log(`Saving assessment results to path: ${path}`);
                await database.ref(path).set(assessmentData);
                
                alert('Assessment results saved successfully!');
                
                // Reset form - using actual form element IDs
                document.getElementById('fixationDuration').value = 0;
                document.getElementById('pursuitCount').value = '0';
                document.getElementById('notes').value = '';
                
                // Reset variables
                assessmentDuration = 0;
                interactionCount = 0;
                firstTapTime = 0;
                hasRecordedFirstTap = false;
                pausedTime = 0;
                pauseStartTime = 0;
                xPos = 0;
                yPos = 0;
                isReversed = false;
                
                // Reset button states
                updateButtonStates();
                
                // Reset eye tracking data
                eyeMovementData = [];
                eyeMovementCount = 0;
                eyeballMovementCount = 0;
                eyeballVectorHistory = [];
                eyeFixationCount = 0;
                eyeFixationDuration = 0;
                followingScore = 0;
                followingHistory = [];
                lightPosition = { x: 0, y: 0 };
                lastLightPosition = { x: 0, y: 0 };
                
                // Reload previous assessments
                loadPreviousAssessments();
                
            } catch (error) {
                console.error('Error saving assessment results:', error);
                alert('Failed to save assessment results: ' + error.message);
            }
        }
        
        // Load previous assessments
        async function loadPreviousAssessments() {
            const user = auth.currentUser;
            if (!user) return;
            
            try {
                let path;
                
                // Check if this is a patient assessment (doctor viewing patient)
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                const doctorId = sessionStorage.getItem('doctorId');
                
                if (currentPatientId && doctorId) {
                    // This is a doctor viewing a patient
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/mirror`;
                } else {
                    // Regular user
                    // Check if user is a doctor
                    const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                    const role = roleSnapshot.val();
                    
                    if (role === 'doctor') {
                        path = `doctors/${user.uid}/quiz/mirror`;
                    } else {
                        path = `users/${user.uid}/quiz/mirror`;
                    }
                }
                
                console.log(`Loading previous assessments from path: ${path}`);
                const assessmentsSnapshot = await database.ref(path).once('value');
                const assessments = assessmentsSnapshot.val();
                
                const reportList = document.getElementById('report-list');
                reportList.innerHTML = '';
                
                if (assessments) {
                    const assessmentIds = Object.keys(assessments).sort((a, b) => b - a); // Sort by timestamp descending
                    
                    // Show the report container
                    document.getElementById('report-container').style.display = 'flex';
                    
                    assessmentIds.forEach((id, index) => {
                        const assessment = assessments[id];
                        const date = new Date(parseInt(id));
                        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                        
                        const li = document.createElement('li');
                        li.className = 'attempt-item';
                        
                        // Create summary with flattened data structure
                        const summary = document.createElement('div');
                        summary.className = 'attempt-summary';
                        summary.innerHTML = `
                            <span><strong>Date:</strong> ${formattedDate}</span>
                            <span><strong>Pattern:</strong> ${assessment.pattern || 'Unknown'}</span>
                            <span><strong>Duration:</strong> ${assessment.assessmentDuration ? assessment.assessmentDuration.toFixed(1) : '0'}s</span>
                            <span><strong>Eye Track:</strong> ${assessment.eyeTrackingEnabled ? 'On' : 'Off'}</span>
                        `;
                        
                        // Create toggle button
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'toggle-details-btn';
                        toggleBtn.textContent = 'Show Details';
                        toggleBtn.dataset.expanded = 'false';
                        
                        // Create details container
                        const details = document.createElement('div');
                        details.className = 'attempt-details';
                        details.style.display = 'none';
                        
                        // Add details using flat data structure
                        // Prepare a flat list of all detail items
                        let detailRows = '';
                        
                        // Basic assessment details
                        detailRows += `
                            <div class="detail-row">
                                <span class="detail-label">Assessment Duration:</span>
                                <span>${assessment.assessmentDuration ? assessment.assessmentDuration.toFixed(1) : '0'}s</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">First Tap Time:</span>
                                <span>${assessment.firstTapTime ? assessment.firstTapTime.toFixed(2) : '0'}s</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Total Interactions:</span>
                                <span>${assessment.interactionCount || 0}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Speed Setting:</span>
                                <span>${assessment.speed || 0}/10</span>
                            </div>`;
                        
                        // Mirror fixation data
                        detailRows += `
                            <div class="detail-row detail-section-header">
                                <span>Mirror Fixation Assessment</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Time Looking at Reflection:</span>
                                <span>${assessment.fixationDuration || 0} seconds</span>
                            </div>`;
                            
                        // Pursuit test data
                        detailRows += `
                            <div class="detail-row detail-section-header">
                                <span>Light Pursuit Assessment</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Pattern Used:</span>
                                <span>${assessment.pattern || 'horizontal'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Successful Pursuits:</span>
                                <span>${assessment.pursuitCount || 0}/5 (${assessment.pursuitSuccessRate || 0}%)</span>
                            </div>`;
                        
                        // Eye tracking data
                        if (assessment.eyeTrackingEnabled) {
                            detailRows += `
                            <div class="detail-row">
                                <span class="detail-label">Face Movements:</span>
                                <span>${assessment.faceMovementCount || 0}</span>
                            </div>
                            <div class="detail-row highlight-row">
                                <span class="detail-label">Eyeball Movements:</span>
                                <span>${assessment.eyeballMovementCount || 0}</span>
                            </div>`;
                            
                            // Add following light score
                            const followingScore = assessment.followingLightScore;
                            if (followingScore !== undefined && followingScore !== null && !isNaN(followingScore)) {
                                const scorePercent = (followingScore * 100).toFixed(0);
                                const scoreColor = (followingScore > 0.5) ? 'green' : 'orange';
                                detailRows += `
                                <div class="detail-row highlight-row">
                                    <span class="detail-label">Following Light Score:</span>
                                    <span><span style="color:${scoreColor}">${scorePercent}%</span></span>
                                </div>`;
                            }
                            
                            // Add eye fixation duration
                            const eyeFixDuration = assessment.eyeFixationDuration;
                            if (eyeFixDuration !== undefined && eyeFixDuration !== null && !isNaN(eyeFixDuration)) {
                                detailRows += `
                                <div class="detail-row">
                                    <span class="detail-label">Eye Fixation Duration:</span>
                                    <span>${eyeFixDuration.toFixed(1)}s</span>
                                </div>`;
                            }
                        }
                        
                        // Add notes if they exist
                        if (assessment.notes) {
                            detailRows += `
                            <div class="detail-row">
                                <span class="detail-label">Notes:</span>
                                <span>${assessment.notes}</span>
                            </div>`;
                        }
                        
                        // Set the HTML content
                        details.innerHTML = detailRows;
                        
                        // Add toggle functionality
                        toggleBtn.addEventListener('click', function() {
                            const isExpanded = this.dataset.expanded === 'true';
                            if (isExpanded) {
                                details.style.display = 'none';
                                this.textContent = 'Show Details';
                                this.dataset.expanded = 'false';
                            } else {
                                details.style.display = 'block';
                                this.textContent = 'Hide Details';
                                this.dataset.expanded = 'true';
                            }
                        });
                        
                        // Append everything to the list item
                        li.appendChild(summary);
                        li.appendChild(toggleBtn);
                        li.appendChild(details);
                        
                        // Add to report list
                        reportList.appendChild(li);
                    });
                } else {
                    reportList.innerHTML = '<p>No previous assessments found.</p>';
                    document.getElementById('report-container').style.display = 'flex';
                }
                
            } catch (error) {
                console.error('Error loading previous assessments:', error);
            }
        }
        
        // Clear all assessment reports
        async function clearReport() {
            const user = auth.currentUser;
            if (!user) {
                alert('You need to be logged in to clear reports.');
                return;
            }
            
            if (!confirm('Are you sure you want to delete all assessment records? This action cannot be undone.')) {
                return;
            }
            
            try {
                let path;
                
                // Check if this is a patient assessment (doctor viewing patient)
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                const doctorId = sessionStorage.getItem('doctorId');
                
                if (currentPatientId && doctorId) {
                    // This is a doctor viewing a patient
                    console.log(`Clearing patient assessment results - Doctor: ${doctorId}, Patient: ${currentPatientId}`);
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/mirror`;
                } else {
                    // Regular user
                    // Check if user is a doctor
                    const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                    const role = roleSnapshot.val();
                    
                    if (role === 'doctor') {
                        console.log(`Clearing doctor's own assessment results: ${user.uid}`);
                        path = `doctors/${user.uid}/quiz/mirror`;
                    } else {
                        console.log(`Clearing regular user assessment results: ${user.uid}`);
                        path = `users/${user.uid}/quiz/mirror`;
                    }
                }
                
                console.log(`Removing all assessment results from path: ${path}`);
                
                // Remove all data at the specified path
                await database.ref(path).remove();
                
                // Reset the results display
                document.getElementById('report-list').innerHTML = '<p>No previous assessments found.</p>';
                
                alert('All assessment reports have been cleared successfully.');
                
            } catch (error) {
                console.error('Error clearing reports:', error);
                alert('Failed to clear reports: ' + error.message);
            }
        }
        
        // Start eye tracking
        function startEyeTracking() {
            if (!isFaceDetectionInitialized || !enableEyeTracking) return;
            
            // Clear any existing interval
            if (detectionInterval) {
                clearInterval(detectionInterval);
            }
            
            // Setup canvas for drawing
            const videoEl = document.getElementById('camera');
            const canvas = document.getElementById('overlay');
            const displaySize = { width: videoEl.width, height: videoEl.height };
            faceapi.matchDimensions(canvas, displaySize);
            
            // Reset tracking data
            eyeMovementData = [];
            lastEyePosition = { x: 0, y: 0 };
            lastEyeballVector = { x: 0, y: 0 };
            eyeballVectorHistory = [];
            lastFacePosition = { x: 0, y: 0 };
            eyeMovementCount = 0;
            eyeballMovementCount = 0;
            eyeFixationCount = 0;
            eyeFixationDuration = 0;
            lastDetectionTime = Date.now();
            detectionFrameCount = 0;
            isFollowingLight = false;
            followingScore = 0;
            followingHistory = [];
            lightPosition = { x: 0, y: 0 };
            lastLightPosition = { x: 0, y: 0 };
            isCalibrated = false;
            calibrationPoints = [];
            maxEyeballMovement = 5.0;
            eyeballNoiseThreshold = 0.8;
            
            // Start detection loop
            detectionInterval = setInterval(async () => {
                try {
                    if (!videoEl.paused && !videoEl.ended) {
                        // Calculate framerate
                        const now = Date.now();
                        detectionFrameCount++;
                        if (now - lastDetectionTime >= 1000) {
                            frameRate = detectionFrameCount;
                            detectionFrameCount = 0;
                            lastDetectionTime = now;
                        }
                        
                        // Detect faces with landmarks and expressions for better face fitting
                        const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 224, scoreThreshold: 0.5 });
                        const detections = await faceapi.detectSingleFace(videoEl, options)
                            .withFaceLandmarks()
                            .withFaceExpressions();
                        
                        // Clear canvas
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        if (detections) {
                            // Get face position to isolate eyeball movements from face movements
                            const faceBox = detections.detection.box;
                            const currentFacePosition = {
                                x: faceBox.x + faceBox.width/2,
                                y: faceBox.y + faceBox.height/2
                            };
                            
                            // Extract eye landmarks
                            const leftEye = detections.landmarks.getLeftEye();
                            const rightEye = detections.landmarks.getRightEye();
                            
                            // Calculate eye centers
                            const leftEyeCenter = calculateEyeCenter(leftEye);
                            const rightEyeCenter = calculateEyeCenter(rightEye);
                            
                            // Enhanced iris detection with weighted approach to get better pupil estimation
                            const leftIris = calculateEnhancedIrisPosition(leftEye, "left");
                            const rightIris = calculateEnhancedIrisPosition(rightEye, "right");
                            
                            // Calculate eyeball vectors (direction iris is looking relative to eye center)
                            const leftEyeballVector = {
                                x: leftIris.x - leftEyeCenter.x,
                                y: leftIris.y - leftEyeCenter.y
                            };
                            
                            const rightEyeballVector = {
                                x: rightIris.x - rightEyeCenter.x,
                                y: rightIris.y - rightEyeCenter.y
                            };
                            
                            // Calculate eyeball vector magnitudes for movement detection
                            const leftMagnitude = Math.sqrt(leftEyeballVector.x * leftEyeballVector.x + leftEyeballVector.y * leftEyeballVector.y);
                            const rightMagnitude = Math.sqrt(rightEyeballVector.x * rightEyeballVector.x + rightEyeballVector.y * rightEyeballVector.y);
                            
                            // Simple, logical eye status detection
                            // If we have valid iris positions with meaningful magnitude, we can track gaze
                            // This is what matters for CVI assessment - can we track their gaze?
                            const eyesOpen = leftIris && rightIris && 
                                           leftMagnitude > 0.5 && rightMagnitude > 0.5;
                            
                            // Average eyeball vector - only consider if eyes are open
                            const rawAvgEyeballVector = {
                                x: (leftEyeballVector.x + rightEyeballVector.x) / 2,
                                y: (leftEyeballVector.y + rightEyeballVector.y) / 2
                            };
                            
                            // Add to history for smoothing
                            if (eyesOpen) {
                                eyeballVectorHistory.push(rawAvgEyeballVector);
                                // Limit history size
                                if (eyeballVectorHistory.length > EYEBALL_HISTORY_SIZE) {
                                    eyeballVectorHistory.shift();
                                }
                            }
                            
                            // Apply smoothing to reduce noise and improve accuracy
                            const avgEyeballVector = smoothEyeballVector(eyeballVectorHistory);
                            
                            // Draw face landmarks if visual tracking is enabled
                            if (showTrackingVisuals) {
                                // Draw face box with lower opacity to show we're tracking it but it's not the focus
                                ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(faceBox.x, faceBox.y, faceBox.width, faceBox.height);
                                
                                // Draw eye landmarks
                                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                                ctx.beginPath();
                                leftEye.forEach((point, i) => {
                                    if (i === 0) ctx.moveTo(point.x, point.y);
                                    else ctx.lineTo(point.x, point.y);
                                });
                                ctx.closePath();
                                ctx.stroke();
                                
                                ctx.beginPath();
                                rightEye.forEach((point, i) => {
                                    if (i === 0) ctx.moveTo(point.x, point.y);
                                    else ctx.lineTo(point.x, point.y);
                                });
                                ctx.closePath();
                                ctx.stroke();
                                
                                // Highlight eye centers
                                ctx.fillStyle = '#00ff00';
                                ctx.beginPath();
                                ctx.arc(leftEyeCenter.x, leftEyeCenter.y, 2, 0, 2 * Math.PI);
                                ctx.arc(rightEyeCenter.x, rightEyeCenter.y, 2, 0, 2 * Math.PI);
                                ctx.fill();
                                
                                // Highlight iris/pupils
                                ctx.fillStyle = '#ff0000';
                                ctx.beginPath();
                                ctx.arc(leftIris.x, leftIris.y, 3, 0, 2 * Math.PI);
                                ctx.arc(rightIris.x, rightIris.y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                                
                                // Draw eyeball direction vectors
                                ctx.strokeStyle = '#ff00ff';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(leftEyeCenter.x, leftEyeCenter.y);
                                ctx.lineTo(leftEyeCenter.x + leftEyeballVector.x * 3, leftEyeCenter.y + leftEyeballVector.y * 3);
                                ctx.moveTo(rightEyeCenter.x, rightEyeCenter.y);
                                ctx.lineTo(rightEyeCenter.x + rightEyeballVector.x * 3, rightEyeCenter.y + rightEyeballVector.y * 3);
                                ctx.stroke();
                            }
                            
                            // Calculate average eye position
                            const avgEyePos = {
                                x: (leftEyeCenter.x + rightEyeCenter.x) / 2,
                                y: (leftEyeCenter.y + rightEyeCenter.y) / 2
                            };
                            
                            // Check for overall face movement with balanced threshold
                            const faceMovementThreshold = 10; // pixels - increased for less sensitivity
                            const faceMovement = Math.sqrt(
                                Math.pow(currentFacePosition.x - lastFacePosition.x, 2) + 
                                Math.pow(currentFacePosition.y - lastFacePosition.y, 2)
                            );
                            
                            // Auto-calibrate eyeball movement threshold with balanced sensitivity
                            if (eyesOpen && eyeballVectorHistory.length >= 5) {
                                const currMagnitude = Math.sqrt(
                                    avgEyeballVector.x * avgEyeballVector.x + 
                                    avgEyeballVector.y * avgEyeballVector.y
                                );
                                
                                // Update maximum observed eyeball movement with reasonable cap
                                if (currMagnitude > maxEyeballMovement && currMagnitude < 10) {
                                    maxEyeballMovement = currMagnitude;
                                    // Set threshold to filter out noise but detect real movements
                                    eyeballNoiseThreshold = Math.max(0.15, maxEyeballMovement * 0.2); // 20% of max for balanced detection
                                }
                            }
                            
                            // Calculate eyeball movement with dynamically calibrated threshold
                            const eyeballMovement = Math.sqrt(
                                Math.pow(avgEyeballVector.x - lastEyeballVector.x, 2) + 
                                Math.pow(avgEyeballVector.y - lastEyeballVector.y, 2)
                            );
                            
                            // Get light stimulus position with improved accuracy
                            const lightStimulus = document.getElementById('lightStimulus');
                            const lightRect = lightStimulus.getBoundingClientRect();
                            const videoRect = videoEl.getBoundingClientRect();
                            
                            // Convert to canvas coordinates with proper scaling
                            const canvasLightPos = {
                                x: ((lightRect.left + lightRect.width/2) - videoRect.left) * (canvas.width / videoRect.width),
                                y: ((lightRect.top + lightRect.height/2) - videoRect.top) * (canvas.height / videoRect.height)
                            };
                            
                            // Store light position change for movement detection
                            const lightMovement = {
                                x: canvasLightPos.x - lastLightPosition.x,
                                y: canvasLightPos.y - lastLightPosition.y
                            };
                            const lightMoved = Math.sqrt(lightMovement.x * lightMovement.x + lightMovement.y * lightMovement.y) > 2;
                            lastLightPosition = { ...canvasLightPos };
                            lightPosition = { ...canvasLightPos };
                            
                            // Check if eyes are looking toward light stimulus
                            const eyesToLightVector = {
                                x: canvasLightPos.x - avgEyePos.x,
                                y: canvasLightPos.y - avgEyePos.y
                            };
                            
                            // Normalize vectors
                            const normalizeVector = (vector) => {
                                const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                                return magnitude === 0 ? vector : { 
                                    x: vector.x / magnitude, 
                                    y: vector.y / magnitude 
                                };
                            };
                            
                            const normEyeballVector = normalizeVector(avgEyeballVector);
                            const normLightVector = normalizeVector(eyesToLightVector);
                            
                            // Dot product to calculate similarity of direction (1 = same direction, -1 = opposite)
                            const dotProduct = normEyeballVector.x * normLightVector.x + normEyeballVector.y * normLightVector.y;
                            
                            // Stricter light following detection
                            let followingDetected = false;
                            
                            // Higher threshold - eyes must be well-aligned with light
                            followingDetected = dotProduct > 0.65;
                            
                            // Additional methods to increase detection rates
                            if (!followingDetected) {
                                // Try alternate detection: is eyeball pointing roughly in same quadrant as light?
                                const eyeQuadrant = getQuadrant(avgEyeballVector);
                                const lightQuadrant = getQuadrant(eyesToLightVector);
                                
                                // Consider following if pointing in same or adjacent quadrant
                                if (eyeQuadrant === lightQuadrant || areAdjacentQuadrants(eyeQuadrant, lightQuadrant)) {
                                    followingDetected = true;
                                }
                                
                                // Also check if eye movement vector is pointing in general light direction
                                if (lastEyeballVector.x !== 0) {
                                    const eyeMovementVector = {
                                        x: avgEyeballVector.x - lastEyeballVector.x,
                                        y: avgEyeballVector.y - lastEyeballVector.y
                                    };
                                    
                                    const eyeMoveMagnitude = Math.sqrt(
                                        eyeMovementVector.x * eyeMovementVector.x +
                                        eyeMovementVector.y * eyeMovementVector.y
                                    );
                                    
                                    // If significant eye movement occurred
                                    if (eyeMoveMagnitude > 0.05) {
                                        const normEyeMovement = normalizeVector(eyeMovementVector);
                                        const moveToLightAlignment = normEyeMovement.x * normLightVector.x +
                                                                    normEyeMovement.y * normLightVector.y;
                                        
                                        // Stricter threshold for directional alignment
                                        if (moveToLightAlignment > 0.6) {
                                            followingDetected = true;
                                        }
                                    }
                                }
                            }
                            
                            // Update following score (sliding window for more stability)
                            followingHistory.push(followingDetected ? 1 : 0);
                            if (followingHistory.length > FOLLOWING_HISTORY_SIZE) {
                                followingHistory.shift();
                            }
                            
                            // Calculate weighted score that prioritizes recent frames
                            const weightedFollowingScore = calculateWeightedScore(followingHistory);
                            followingScore = weightedFollowingScore;
                            
                            // Stricter threshold for sustained following
                            isFollowingLight = followingScore > 0.7;
                            
                            // Draw line from eye to light if following
                            if (showTrackingVisuals && isFollowingLight) {
                                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([5, 3]);
                                ctx.beginPath();
                                ctx.moveTo(avgEyePos.x, avgEyePos.y);
                                ctx.lineTo(canvasLightPos.x, canvasLightPos.y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }
                            
                            // Logical eyeball movement detection for CVI assessment
                            // Count meaningful gaze redirections (saccades), filter out noise
                            // Clinical relevance: How many times did the child redirect their gaze?
                            if (eyesOpen && eyeballMovement > eyeballNoiseThreshold * 1.2) {
                                // Eyeball movement detected (eyes must be open)
                                eyeballMovementCount++;
                                eyeFixationCount = 0; // Reset fixation counter
                                
                                // Draw eyeball movement path if visual tracking is enabled
                                if (showTrackingVisuals && lastEyeballVector.x !== 0) {
                                    ctx.strokeStyle = '#ff0000';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.moveTo(avgEyePos.x, avgEyePos.y);
                                    ctx.lineTo(avgEyePos.x + avgEyeballVector.x * 5, avgEyePos.y + avgEyeballVector.y * 5);
                                    ctx.stroke();
                                }
                                
                                // Record eyeball movement data
                                eyeMovementData.push({
                                    timestamp: Date.now(),
                                    position: { ...avgEyePos },
                                    eyeballVector: { ...avgEyeballVector },
                                    isMovement: true,
                                    followingLight: isFollowingLight
                                });
                            } else if (faceMovement >= faceMovementThreshold) {
                                // Face movement detected, but not counting as eyeball movement
                                eyeMovementCount++;
                            } else if (eyesOpen) {
                                // Eye fixation detected (only when eyes are open)
                                eyeFixationCount++;
                                if (eyeFixationCount >= 5 && frameRate > 0) { // About 0.25 seconds at 20fps
                                    // Prevent infinity: check frameRate is valid
                                    const increment = frameRate > 0 ? 1/frameRate : 0.05;
                                    eyeFixationDuration += increment;
                                    
                                    // Safety cap to prevent runaway values
                                    if (eyeFixationDuration > 300) eyeFixationDuration = 300;
                                    
                                    // Mark fixation point if visual tracking is enabled
                                    if (showTrackingVisuals) {
                                        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                                        ctx.beginPath();
                                        ctx.arc(avgEyePos.x, avgEyePos.y, 5, 0, 2 * Math.PI);
                                        ctx.fill();
                                    }
                                    
                                    // Record eye fixation data
                                    eyeMovementData.push({
                                        timestamp: Date.now(),
                                        position: { ...avgEyePos },
                                        eyeballVector: { ...avgEyeballVector },
                                        isMovement: false,
                                        fixationDuration: eyeFixationDuration,
                                        followingLight: isFollowingLight
                                    });
                                }
                            }
                            
                            // Update last positions
                            lastEyePosition = { ...avgEyePos };
                            lastEyeballVector = { ...avgEyeballVector };
                            lastFacePosition = { ...currentFacePosition };
                            
                            // Clear, simple detection display
                            document.getElementById('detectionData').innerHTML = `
                                <b>Eyes:</b> ${eyesOpen ? '<span style="color:green">Tracking</span>' : '<span style="color:gray">Not visible</span>'}<br>
                                <b>Gaze movements:</b> ${eyeballMovementCount}<br>
                                <b>Following light:</b> ${isFollowingLight ? '<span style="color:green">Yes</span>' : 'No'} (${(followingScore * 100).toFixed(0)}%)<br>
                                <b>Cumulative fixation:</b> ${eyeFixationDuration.toFixed(1)}s<br>
                                Head movements: ${eyeMovementCount} | FPS: ${frameRate}
                            `;
                            
                            // UPDATE CLINICAL ASSESSMENT DISPLAYS
                            // Only update if assessment is actually running (not stopped)
                            if (isRunning && !isPaused) {
                                updateAssessmentDisplays(false);
                            }
                            // If stopped but eye tracking still active, keep final values displayed
                            else if (!isRunning && finalFixationDuration > 0) {
                                // Don't update - displays remain frozen with final values
                                // This ensures the display never changes after stop
                            }
                        } else {
                            document.getElementById('detectionData').textContent = 'No face detected';
                        }
                    }
                } catch (error) {
                    console.error('Error in eye tracking:', error);
                }
            }, 50); // 20 fps
        }
        
        // Update assessment display panels
        function updateAssessmentDisplays(isFinal) {
            const autoFixationDisplay = document.getElementById('autoFixationValue');
            const autoPursuitDisplay = document.getElementById('autoPursuitValue');
            const autoFollowingDisplay = document.getElementById('autoFollowingValue');
            
            const autoMovementDisplay = document.getElementById('autoMovementValue');
            
            // Use appropriate values based on state
            const fixValue = isFinal ? finalFixationDuration : eyeFixationDuration;
            const followValue = isFinal ? finalFollowingScore : followingScore;
            const moveValue = eyeballMovementCount;
            
            // Calculate pursuit quality
            let pursuitQuality = '--';
            if (isFinal || (isRunning && assessmentDuration > 3)) {
                if (followValue > 0.7) pursuitQuality = 'Excellent';
                else if (followValue > 0.5) pursuitQuality = 'Good';
                else if (followValue > 0.3) pursuitQuality = 'Fair';
                else if (followValue > 0.1) pursuitQuality = 'Poor';
                else pursuitQuality = 'Minimal';
            }
            
            // Update displays with clean values
            if (autoFixationDisplay) {
                const displayValue = isFinite(fixValue) ? fixValue.toFixed(1) : '0.0';
                autoFixationDisplay.textContent = `${displayValue}s`;
                autoFixationDisplay.style.color = isFinal ? '#4CAF50' : '#2196F3';
            }
            
            if (autoPursuitDisplay) {
                autoPursuitDisplay.textContent = pursuitQuality;
                const colorMap = {
                    'Excellent': '#4CAF50',
                    'Good': '#8BC34A',
                    'Fair': '#FFC107',
                    'Poor': '#FF9800',
                    'Minimal': '#F44336',
                    '--': '#999'
                };
                autoPursuitDisplay.style.color = isFinal ? colorMap[pursuitQuality] : '#2196F3';
            }
            
            if (autoMovementDisplay) {
                autoMovementDisplay.textContent = moveValue.toString();
                autoMovementDisplay.style.color = isFinal ? '#4CAF50' : '#2196F3';
            }
        }
        
        // Stop eye tracking
        function stopEyeTracking() {
            if (detectionInterval) {
                clearInterval(detectionInterval);
                detectionInterval = null;
            }
            document.getElementById('detectionData').textContent = 'Eye tracking disabled';
            
            // Clear overlay canvas
            const canvas = document.getElementById('overlay');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Calculate eye center from landmarks
        function calculateEyeCenter(eyePoints) {
            let sumX = 0;
            let sumY = 0;
            
            for (let i = 0; i < eyePoints.length; i++) {
                sumX += eyePoints[i].x;
                sumY += eyePoints[i].y;
            }
            
            return {
                x: sumX / eyePoints.length,
                y: sumY / eyePoints.length
            };
        }
        
        // Simplified iris position calculation that exaggerates movements for better detection
        function calculateEnhancedIrisPosition(eyePoints, eyeSide) {
            // Use all eye landmarks with simple weighting
            const centerX = eyePoints.reduce((sum, p) => sum + p.x, 0) / eyePoints.length;
            const centerY = eyePoints.reduce((sum, p) => sum + p.y, 0) / eyePoints.length;
            
            // Find the inner and outer corners (usually at indices 0 and 3)
            const innerCornerIdx = eyeSide === "left" ? 3 : 0;
            const outerCornerIdx = eyeSide === "left" ? 0 : 3;
            
            // Top and bottom points (usually indices 1 and 2 or 4 and 5)
            const topIdx = eyeSide === "left" ? 1 : 4;
            const bottomIdx = eyeSide === "left" ? 2 : 5;
            
            // Get eye dimensions
            const eyeWidth = Math.abs(eyePoints[outerCornerIdx].x - eyePoints[innerCornerIdx].x);
            const eyeHeight = Math.abs(eyePoints[topIdx].y - eyePoints[bottomIdx].y);
            
            // Use a central point biased toward inner corner for better iris estimation
            let irisX;
            let irisY;
            
            if (eyeSide === "left") {
                // Left eye - bias toward inner (right) corner
                irisX = centerX + eyeWidth * 0.1; // Slight bias right
                irisY = centerY;
            } else {
                // Right eye - bias toward inner (left) corner
                irisX = centerX - eyeWidth * 0.1; // Slight bias left
                irisY = centerY;
            }
            
            // Exaggerate iris position using eye gaze approximation based on eye shape
            const topBottomDiff = eyePoints[topIdx].y - eyePoints[bottomIdx].y;
            const innerOuterDiff = eyePoints[innerCornerIdx].x - eyePoints[outerCornerIdx].x;
            
            // Exaggerate up/down position variation
            if (Math.abs(topBottomDiff) > 0.2 * eyeHeight) {
                const verticalFactor = 0.2 * Math.sign(topBottomDiff) * eyeHeight;
                irisY += verticalFactor;
            }
            
            // Exaggerate left/right position variation
            if (Math.abs(innerOuterDiff) > 0.1 * eyeWidth) {
                const horizontalFactor = 0.25 * Math.sign(innerOuterDiff) * eyeWidth;
                irisX += horizontalFactor;
            }
            
            return { x: irisX, y: irisY };
        }
        
        // Get eye width helper function
        function getEyeWidth(eyePoints) {
            // Typically points 0 and 3 are the outer and inner corners
            const leftX = Math.min(...eyePoints.map(p => p.x));
            const rightX = Math.max(...eyePoints.map(p => p.x));
            return rightX - leftX;
        }
        
        // Get eye height helper function
        function getEyeHeight(eyePoints) {
            // Typically points 1, 2 are top and bottom of eye
            const topY = Math.min(...eyePoints.map(p => p.y));
            const bottomY = Math.max(...eyePoints.map(p => p.y));
            return bottomY - topY;
        }
        
        // Less aggressive smoothing to preserve more of the original movement
        function smoothEyeballVector(history) {
            if (history.length === 0) return { x: 0, y: 0 };
            if (history.length === 1) return history[0]; // Don't smooth single entries
            
            // If only 2-3 entries, just take most recent one with slight averaging
            if (history.length <= 3) {
                const latest = history[history.length-1];
                const prev = history[history.length-2];
                
                // 80% current, 20% previous - preserves more movement
                return {
                    x: latest.x * 0.8 + prev.x * 0.2,
                    y: latest.y * 0.8 + prev.y * 0.2
                };
            }
            
            // For longer history, use simplified weighting that preserves more of recent movements
            // The most recent entry gets 60% weight, rest is averaged
            const latest = history[history.length-1];
            
            let sumX = 0;
            let sumY = 0;
            
            // Average previous entries (excluding latest)
            for (let i = 0; i < history.length-1; i++) {
                sumX += history[i].x;
                sumY += history[i].y;
            }
            
            const avgPrevious = {
                x: sumX / (history.length-1),
                y: sumY / (history.length-1)
            };
            
            // Combine with heavy weighting to latest (60/40 split)
            return {
                x: latest.x * 0.6 + avgPrevious.x * 0.4,
                y: latest.y * 0.6 + avgPrevious.y * 0.4
            };
        }
        
        // Get quadrant helper function (1-4, clockwise from top-right)
        function getQuadrant(vector) {
            if (vector.x >= 0 && vector.y < 0) return 1; // top-right
            if (vector.x >= 0 && vector.y >= 0) return 2; // bottom-right
            if (vector.x < 0 && vector.y >= 0) return 3; // bottom-left
            return 4; // top-left
        }
        
        // Check if quadrants are adjacent
        function areAdjacentQuadrants(q1, q2) {
            if (Math.abs(q1 - q2) === 1) return true; // adjacent normally
            if ((q1 === 1 && q2 === 4) || (q1 === 4 && q2 === 1)) return true; // wrap around
            return false;
        }
        
        // Calculate weighted score for following detection
        function calculateWeightedScore(history) {
            if (history.length === 0) return 0;
            
            let sumScore = 0;
            let sumWeights = 0;
            
            for (let i = 0; i < history.length; i++) {
                // More recent entries get exponentially higher weight
                const weight = Math.pow(1.5, i) / Math.pow(1.5, history.length - 1);
                sumScore += history[i] * weight;
                sumWeights += weight;
            }
            
            return sumScore / sumWeights;
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            stopEyeTracking();
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
