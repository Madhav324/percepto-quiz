<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVI Fixation Mirror Assessment</title>
    <!-- face-api.js for eye tracking -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 15px;
        }

        .container {
            text-align: center;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 650px;
            padding: 20px;
            position: relative;
        }

        /* Header and profile styles */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        h1 {
            font-size: 22px;
            color: #333;
            margin: 0;
        }
        
        h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }
        
        /* Profile Icon */
        .profile-icon {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
        
        .profile-icon:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .patient-indicator {
            display: inline-block;
            background-color: #e9f5e9;
            color: #4CAF50;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }

        /* Camera container */
        .camera-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 0;
            padding-bottom: 75%; /* 4:3 aspect ratio */
            margin: 0 auto 20px;
            overflow: hidden;
            border-radius: 8px;
        }

        #camera {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        /* Mirror frames */
        .mirror-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            border: 15px solid;
            border-radius: 8px;
        }

        .classic-mirror {
            border-color: #c0c0c0;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }

        .led-mirror {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.8), inset 0 0 10px rgba(255,255,255,0.5);
        }

        .toy-mirror {
            border-color: #ff9800;
            border-style: dashed;
            box-shadow: inset 0 0 10px rgba(255,152,0,0.5);
        }

        /* Light stimulus */
        .light-stimulus {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,0,0.8) 70%);
            box-shadow: 0 0 15px rgba(255,255,0,0.8);
            z-index: 10;
            pointer-events: none;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #333;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        button {
            padding: 8px 15px;
            border: none;
            background-color: #4CAF50;
            color: white;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        /* Observation checklist */
        .observation-container {
            margin-top: 20px;
            text-align: left;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }

        .observation-container h3 {
            font-size: 16px;
            margin-bottom: 10px;
        }

        .observation-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .observation-item input[type="checkbox"] {
            margin-right: 10px;
        }

        /* Report container */
        #report-container {
            margin-top: 40px;
            width: 100%;
            max-width: 600px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* Enhanced report styles */
        .attempt-details {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            width: 100%;
        }
        
        .detail-section {
            margin-top: 10px;
            padding: 8px;
            background-color: #f0f7f0;
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }
        
        .detail-section h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #2e7d32;
        }
        
        .highlight-row {
            font-weight: bold;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        /* Eye tracking overlay */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
        }
        
        .detection-data {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 20;
            max-width: 250px;
        }
        
        .eye-track-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            align-items: center;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .toggle-switch label {
            font-size: 12px;
            cursor: pointer;
        }

        /* Responsive styles */
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            .camera-container {
                padding-bottom: 100%; /* Square aspect ratio on mobile */
            }
            
            .mirror-frame {
                border-width: 10px;
            }
            
            .button-group {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CVI Fixation Mirror Assessment</h1>
            <div class="profile-icon" id="profileIcon" title="Back to Home" onclick="window.location.href='index.html'"></div>
        </div>
        
        <div id="patientIndicator" class="patient-indicator" style="display: none;">Patient Assessment</div>
        
        <div class="camera-container">
            <video id="camera" autoplay playsinline></video>
            <div id="mirrorFrame" class="mirror-frame classic-mirror"></div>
            <div id="lightStimulus" class="light-stimulus"></div>
            <canvas id="overlay"></canvas>
            <div class="detection-data" id="detectionData">Eye tracking initializing...</div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="pattern">Movement Pattern:</label>
                <select id="pattern">
                    <option value="linear">Linear (Left to Right)</option>
                    <option value="diagonal">Diagonal</option>
                    <option value="circular">Circular</option>
                    <option value="random">Random</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="speed">Speed:</label>
                <input type="range" id="speed" min="1" max="10" value="5">
            </div>
            
            <div class="control-group">
                <label for="frameStyle">Mirror Style:</label>
                <select id="frameStyle">
                    <option value="classic-mirror">Classic Silver</option>
                    <option value="led-mirror">LED Lights</option>
                    <option value="toy-mirror">Toy Theme</option>
                </select>
            </div>
            
            <div class="button-group">
                <button id="startBtn">Start Stimulus</button>
                <button id="stopBtn">Stop</button>
                <button id="pauseBtn">Pause</button>
                <button id="reverseBtn">Reverse</button>
                <button id="homeBtn" onclick="window.location.href='index.html'">Home</button>
            </div>
            
            <div class="eye-track-controls">
                <div class="toggle-switch">
                    <input type="checkbox" id="enableEyeTracking" checked>
                    <label for="enableEyeTracking">Enable Eye Tracking</label>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="showTrackingVisuals" checked>
                    <label for="showTrackingVisuals">Show Tracking Visuals</label>
                </div>
            </div>
        </div>
        
        <div class="observation-container">
            <h3>Observation Checklist</h3>
            <div class="observation-item">
                <input type="checkbox" id="fixation">
                <label for="fixation">Fixation achieved</label>
            </div>
            <div class="observation-item">
                <input type="checkbox" id="leftField">
                <label for="leftField">Response to left field</label>
            </div>
            <div class="observation-item">
                <input type="checkbox" id="rightField">
                <label for="rightField">Response to right field</label>
            </div>
            <div class="observation-item">
                <input type="checkbox" id="centerField">
                <label for="centerField">Response to center field</label>
            </div>
            <div class="observation-item">
                <label for="duration">Approximate duration of eye contact (seconds):</label>
                <input type="number" id="duration" min="0" max="300" value="0">
            </div>
            <div class="observation-item">
                <label for="notes">Notes:</label>
                <textarea id="notes" rows="3" style="width: 100%;"></textarea>
            </div>
            <div class="button-group">
                <button id="saveBtn">Save Observations</button>
            </div>
        </div>
        
        <div id="report-container">
            <h2>Previous Assessments</h2>
            <ul id="report-list"></ul>
            <button id="clear-report" onclick="clearReport()">Clear Reports</button>
        </div>
    </div>

    <!-- Firebase App (the core Firebase SDK) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <!-- Firebase Auth -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <!-- Firebase Database -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDFENL5Z_2Cewh4p6zp_BZtxL9n0di-9u8",
            authDomain: "projeccvi.firebaseapp.com",
            projectId: "projeccvi",
            storageBucket: "projeccvi.appspot.com",
            messagingSenderId: "198292153802",
            appId: "1:198292153802:web:7d7be38e3721fdea613064",
            measurementId: "G-82VHYJEHFN"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();
        
        // Check if we're in a doctor-patient context
        const isPatientQuiz = sessionStorage.getItem('currentPatientId') !== null;
        const currentPatientId = sessionStorage.getItem('currentPatientId');
        const doctorId = sessionStorage.getItem('doctorId');
        
        console.log('Quiz context in Mirror:', { 
            isPatientQuiz, 
            currentPatientId: currentPatientId || 'none',
            doctorId: doctorId || 'none'
        });

        // Camera variables
        let camera = document.getElementById('camera');
        let cameraStream = null;
        
        // Light stimulus variables
        let lightStimulus = document.getElementById('lightStimulus');
        let animationId = null;
        let isRunning = false;
        let isPaused = false;
        let isReversed = false;
        let speed = 5;
        let pattern = 'linear';
        let xPos = 50;
        let yPos = 50;
        let angle = 0;
        
        // Assessment data
        let startTime = 0;
        let assessmentDuration = 0;
        let interactionCount = 0;
        
        // Eye tracking variables
        let isFaceDetectionInitialized = false;
        let enableEyeTracking = true;
        let showTrackingVisuals = true;
        let detectionInterval;
        let eyeMovementData = [];
        let lastEyePosition = { x: 0, y: 0 };
        
        // Eyeball tracking with smoothing buffers
        let lastEyeballVector = { x: 0, y: 0 };
        let eyeballVectorHistory = [];
        const EYEBALL_HISTORY_SIZE = 5; // Store recent history for smoothing
        
        let lastFacePosition = { x: 0, y: 0 };
        let eyeMovementCount = 0;
        let eyeballMovementCount = 0;
        let eyeFixationCount = 0;
        let eyeFixationDuration = 0;
        let lastDetectionTime = 0;
        let detectionFrameCount = 0;
        let frameRate = 0;
        
        // Light following variables
        let isFollowingLight = false;
        let followingScore = 0;
        let followingHistory = [];
        const FOLLOWING_HISTORY_SIZE = 15; // Increased window for more stable following detection
        let lightPosition = { x: 0, y: 0 };
        let lastLightPosition = { x: 0, y: 0 };
        
        // Calibration variables - with more permissive defaults
        let isCalibrated = false;
        let calibrationPoints = [];
        let maxEyeballMovement = 2.0; // Higher default for greater leeway
        let eyeballNoiseThreshold = 0.1; // Much lower threshold to detect subtle movements

        // Auth state observer
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                console.log('User authenticated in Mirror:', user.uid);
                
                try {
                    // Check if user is a doctor
                    if (!isPatientQuiz) {
                        const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                        const role = roleSnapshot.val();
                        
                        if (role === 'doctor') {
                            console.log('Doctor authenticated');
                            // Check if we're in doctor-patient context
                            if (currentPatientId && doctorId) {
                                console.log(`Doctor ${doctorId} viewing patient ${currentPatientId}`);
                                // Display patient indicator
                                document.getElementById('patientIndicator').style.display = 'inline-block';
                                
                                // Get patient profile
                                const patientSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/profile`).once('value');
                                profile = patientSnapshot.val();
                            } else {
                                console.log('Doctor viewing their own quiz');
                                // Get doctor profile
                                const doctorSnapshot = await database.ref(`doctors/${user.uid}/profile`).once('value');
                                profile = doctorSnapshot.val();
                            }
                        } else {
                            // Regular user
                            console.log('Loading user profile in Mirror');
                            const userSnapshot = await database.ref(`users/${user.uid}/profile`).once('value');
                            profile = userSnapshot.val();
                        }
                    } else {
                        // Patient context
                        document.getElementById('patientIndicator').style.display = 'inline-block';
                        const patientSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/profile`).once('value');
                        profile = patientSnapshot.val();
                    }
                    
                    // Set profile initial
                    let initial = 'U';
                    if (profile && profile.name) {
                        initial = profile.name.charAt(0).toUpperCase();
                    } else if (user.email) {
                        initial = user.email.charAt(0).toUpperCase();
                    }
                    
                    document.getElementById('profileIcon').textContent = initial;
                    
                    // Initialize camera
                    initCamera();
                    
                    // Load previous assessments
                    loadPreviousAssessments();
                    
                } catch (error) {
                    console.error('Error initializing:', error);
                }
            } else {
                // Not logged in, redirect to login
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                if (!currentPatientId) {
                    window.location.href = 'login.html';
                }
            }
        });
        
        // Initialize camera
        async function initCamera() {
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                camera.srcObject = cameraStream;
                console.log('Camera initialized successfully');
                
                // Initialize face detection after camera is ready
                camera.addEventListener('loadeddata', initFaceDetection);
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Could not access camera. Please check your camera permissions.');
            }
        }
        
        // Initialize face detection models
        async function initFaceDetection() {
            if (isFaceDetectionInitialized) return;
            
            try {
                document.getElementById('detectionData').textContent = 'Loading face detection models...';
                
                // Load required models for face and landmark detection
                await faceapi.nets.tinyFaceDetector.loadFromUri('https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights');
                await faceapi.nets.faceLandmark68Net.loadFromUri('https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights');
                
                // Add face expression model for better landmark fitting
                await faceapi.nets.faceExpressionNet.loadFromUri('https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights');
                
                console.log('Face detection models loaded successfully');
                document.getElementById('detectionData').textContent = 'Face detection ready';
                
                isFaceDetectionInitialized = true;
                
                // Start eye tracking if enabled
                if (enableEyeTracking) {
                    startEyeTracking();
                }
            } catch (error) {
                console.error('Error initializing face detection:', error);
                document.getElementById('detectionData').textContent = 'Error loading detection models';
            }
        }
        
        // Event listeners for controls
        document.getElementById('pattern').addEventListener('change', function() {
            pattern = this.value;
            interactionCount++;
            if (isRunning && !isPaused) {
                stopAnimation();
                startAnimation();
            }
        });
        
        document.getElementById('speed').addEventListener('input', function() {
            speed = parseInt(this.value);
            interactionCount++;
        });
        
        document.getElementById('frameStyle').addEventListener('change', function() {
            const mirrorFrame = document.getElementById('mirrorFrame');
            // Remove all classes
            mirrorFrame.classList.remove('classic-mirror', 'led-mirror', 'toy-mirror');
            // Add selected class
            mirrorFrame.classList.add(this.value);
            interactionCount++;
        });
        
        // Eye tracking toggle controls
        document.getElementById('enableEyeTracking').addEventListener('change', function() {
            enableEyeTracking = this.checked;
            if (enableEyeTracking) {
                startEyeTracking();
            } else {
                stopEyeTracking();
            }
        });
        
        document.getElementById('showTrackingVisuals').addEventListener('change', function() {
            showTrackingVisuals = this.checked;
            const overlay = document.getElementById('overlay');
            overlay.style.display = showTrackingVisuals ? 'block' : 'none';
        });
        
        document.getElementById('startBtn').addEventListener('click', function() {
            startAssessment();
            interactionCount++;
        });
        
        document.getElementById('stopBtn').addEventListener('click', function() {
            stopAssessment();
            interactionCount++;
        });
        
        document.getElementById('pauseBtn').addEventListener('click', function() {
            togglePause();
            interactionCount++;
        });
        
        document.getElementById('reverseBtn').addEventListener('click', function() {
            toggleReverse();
            interactionCount++;
        });
        
        document.getElementById('saveBtn').addEventListener('click', function() {
            saveAssessment();
        });
        
        // Start assessment
        function startAssessment() {
            if (!isRunning) {
                startTime = Date.now();
                startAnimation();
                isRunning = true;
                isPaused = false;
            }
        }
        
        // Stop assessment
        function stopAssessment() {
            if (isRunning) {
                stopAnimation();
                isRunning = false;
                isPaused = false;
                assessmentDuration = (Date.now() - startTime) / 1000; // in seconds
            }
        }
        
        // Toggle pause
        function togglePause() {
            if (isRunning) {
                if (isPaused) {
                    // Resume
                    startAnimation();
                    isPaused = false;
                } else {
                    // Pause
                    stopAnimation();
                    isPaused = true;
                }
            }
        }
        
        // Toggle direction
        function toggleReverse() {
            isReversed = !isReversed;
            if (isRunning && !isPaused) {
                // No need to restart animation, just reverse direction
            }
        }
        
        // Animation functions
        function startAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            animateStimulus();
        }
        
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function animateStimulus() {
            const containerWidth = lightStimulus.parentElement.offsetWidth;
            const containerHeight = lightStimulus.parentElement.offsetHeight;
            const stimulusWidth = lightStimulus.offsetWidth;
            const stimulusHeight = lightStimulus.offsetHeight;
            
            const maxX = containerWidth - stimulusWidth;
            const maxY = containerHeight - stimulusHeight;
            
            // Calculate speed factor (1-10 scale)
            const speedFactor = speed / 5;
            
            // Different movement patterns
            switch(pattern) {
                case 'linear':
                    // Linear movement (left to right)
                    if (!isReversed) {
                        xPos += speedFactor;
                        if (xPos > maxX) xPos = 0;
                    } else {
                        xPos -= speedFactor;
                        if (xPos < 0) xPos = maxX;
                    }
                    break;
                    
                case 'diagonal':
                    // Diagonal movement
                    if (!isReversed) {
                        xPos += speedFactor;
                        yPos += speedFactor;
                        if (xPos > maxX) xPos = 0;
                        if (yPos > maxY) yPos = 0;
                    } else {
                        xPos -= speedFactor;
                        yPos -= speedFactor;
                        if (xPos < 0) xPos = maxX;
                        if (yPos < 0) yPos = maxY;
                    }
                    break;
                    
                case 'circular':
                    // Circular movement
                    angle += (isReversed ? -0.02 : 0.02) * speedFactor;
                    xPos = maxX / 2 + Math.cos(angle) * (maxX / 2.5);
                    yPos = maxY / 2 + Math.sin(angle) * (maxY / 2.5);
                    break;
                    
                case 'random':
                    // Random movement
                    if (Math.random() > 0.95) {
                        xPos += (Math.random() - 0.5) * speedFactor * 10;
                        yPos += (Math.random() - 0.5) * speedFactor * 10;
                        
                        // Keep within bounds
                        xPos = Math.max(0, Math.min(xPos, maxX));
                        yPos = Math.max(0, Math.min(yPos, maxY));
                    }
                    break;
            }
            
            // Update position
            lightStimulus.style.left = `${xPos}px`;
            lightStimulus.style.top = `${yPos}px`;
            
            // Continue animation
            animationId = requestAnimationFrame(animateStimulus);
        }
        
        // Save assessment results
        async function saveAssessment() {
            const user = auth.currentUser;
            if (!user) {
                alert('You need to be logged in to save assessment results.');
                return;
            }
            
            if (!isRunning && assessmentDuration === 0) {
                alert('You need to run an assessment before saving results.');
                return;
            }
            
            // Stop assessment if still running
            if (isRunning) {
                stopAssessment();
            }
            
            try {
                // Get observation data
                const fixation = document.getElementById('fixation').checked;
                const leftField = document.getElementById('leftField').checked;
                const rightField = document.getElementById('rightField').checked;
                const centerField = document.getElementById('centerField').checked;
                const duration = document.getElementById('duration').value;
                const notes = document.getElementById('notes').value;
                
                // Prepare data object with a flat structure
                const timestamp = Date.now();
                const assessmentData = {
                    timestamp,
                    assessmentDuration,
                    interactionCount,
                    pattern,
                    speed,
                    // Observation data (flattened)
                    fixation,
                    leftField,
                    rightField,
                    centerField,
                    duration,
                    notes,
                    // Eye tracking data (flattened)
                    eyeTrackingEnabled: enableEyeTracking,
                    faceMovementCount: eyeMovementCount,
                    eyeballMovementCount: eyeballMovementCount,
                    fixationDuration: eyeFixationDuration,
                    followingLightScore: followingScore,
                    // Only save the last 100 eye movement data points to prevent huge data
                    eyeMovements: eyeMovementData.slice(-100)
                };
                
                // Determine the correct path based on user role
                let path;
                
                // Check if this is a patient assessment (doctor viewing patient)
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                const doctorId = sessionStorage.getItem('doctorId');
                
                if (currentPatientId && doctorId) {
                    // This is a doctor testing a patient
                    console.log(`Saving patient assessment results - Doctor: ${doctorId}, Patient: ${currentPatientId}`);
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/mirror/${timestamp}`;
                } else {
                    // Regular user assessment
                    // Check if user is a doctor
                    const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                    const role = roleSnapshot.val();
                    
                    if (role === 'doctor') {
                        console.log(`Saving doctor's own assessment results: ${user.uid}`);
                        path = `doctors/${user.uid}/quiz/mirror/${timestamp}`;
                    } else {
                        console.log(`Saving regular user assessment results: ${user.uid}`);
                        path = `users/${user.uid}/quiz/mirror/${timestamp}`;
                    }
                }
                
                console.log(`Saving assessment results to path: ${path}`);
                await database.ref(path).set(assessmentData);
                
                alert('Assessment results saved successfully!');
                
                // Reset form
                document.getElementById('fixation').checked = false;
                document.getElementById('leftField').checked = false;
                document.getElementById('rightField').checked = false;
                document.getElementById('centerField').checked = false;
                document.getElementById('duration').value = 0;
                document.getElementById('notes').value = '';
                
                // Reset variables
                assessmentDuration = 0;
                interactionCount = 0;
                
                // Reset eye tracking data
                eyeMovementData = [];
                eyeMovementCount = 0;
                eyeballMovementCount = 0;
                eyeballVectorHistory = [];
                eyeFixationCount = 0;
                eyeFixationDuration = 0;
                followingScore = 0;
                followingHistory = [];
                lightPosition = { x: 0, y: 0 };
                lastLightPosition = { x: 0, y: 0 };
                
                // Reload previous assessments
                loadPreviousAssessments();
                
            } catch (error) {
                console.error('Error saving assessment results:', error);
                alert('Failed to save assessment results: ' + error.message);
            }
        }
        
        // Load previous assessments
        async function loadPreviousAssessments() {
            const user = auth.currentUser;
            if (!user) return;
            
            try {
                let path;
                
                // Check if this is a patient assessment (doctor viewing patient)
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                const doctorId = sessionStorage.getItem('doctorId');
                
                if (currentPatientId && doctorId) {
                    // This is a doctor viewing a patient
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/mirror`;
                } else {
                    // Regular user
                    // Check if user is a doctor
                    const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                    const role = roleSnapshot.val();
                    
                    if (role === 'doctor') {
                        path = `doctors/${user.uid}/quiz/mirror`;
                    } else {
                        path = `users/${user.uid}/quiz/mirror`;
                    }
                }
                
                console.log(`Loading previous assessments from path: ${path}`);
                const assessmentsSnapshot = await database.ref(path).once('value');
                const assessments = assessmentsSnapshot.val();
                
                const reportList = document.getElementById('report-list');
                reportList.innerHTML = '';
                
                if (assessments) {
                    const assessmentIds = Object.keys(assessments).sort((a, b) => b - a); // Sort by timestamp descending
                    
                    // Show the report container
                    document.getElementById('report-container').style.display = 'flex';
                    
                    assessmentIds.forEach((id, index) => {
                        const assessment = assessments[id];
                        const date = new Date(parseInt(id));
                        const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                        
                        const li = document.createElement('li');
                        li.className = 'attempt-item';
                        
                        // Create summary
                        const summary = document.createElement('div');
                        summary.className = 'attempt-summary';
                        summary.innerHTML = `
                            <span><strong>Date:</strong> ${formattedDate}</span>
                            <span><strong>Pattern:</strong> ${assessment.pattern}</span>
                            <span><strong>Duration:</strong> ${assessment.assessmentDuration.toFixed(1)}s</span>
                            <span><strong>Eye Track:</strong> ${assessment.eyeTrackingEnabled ? 'On' : 'Off'}</span>
                        `;
                        
                        // Create toggle button
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'toggle-details-btn';
                        toggleBtn.textContent = 'Show Details';
                        toggleBtn.dataset.expanded = 'false';
                        
                        // Create details container
                        const details = document.createElement('div');
                        details.className = 'attempt-details';
                        details.style.display = 'none';
                        
                        // Add all details in a single flat list
                        details.innerHTML = `
                            <div class="detail-row">
                                <span class="detail-label">Interactions:</span>
                                <span>${assessment.interactionCount}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Speed Setting:</span>
                                <span>${assessment.speed}/10</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Fixation Achieved:</span>
                                <span>${assessment.fixation ? 'Yes' : 'No'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Field Response:</span>
                                <span>
                                    ${assessment.leftField ? 'Left, ' : ''}
                                    ${assessment.centerField ? 'Center, ' : ''}
                                    ${assessment.rightField ? 'Right' : ''}
                                </span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Eye Contact Duration:</span>
                                <span>${assessment.duration}s</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Eye Tracking:</span>
                                <span>${assessment.eyeTrackingEnabled ? 'Enabled' : 'Disabled'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Face Movements:</span>
                                <span>${assessment.faceMovementCount || 0}</span>
                            </div>
                            <div class="detail-row highlight-row">
                                <span class="detail-label">Eyeball Movements:</span>
                                <span>${assessment.eyeballMovementCount || 0}</span>
                            </div>
                            <div class="detail-row highlight-row">
                                <span class="detail-label">Following Light:</span>
                                <span>${assessment.followingLightScore ? 
                                `<span style="color:${(assessment.followingLightScore > 0.5) ? 'green' : 'orange'}">` + 
                                (assessment.followingLightScore * 100).toFixed(0) + '%</span>' : 'N/A'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Auto Fixation Duration:</span>
                                <span>${assessment.fixationDuration ? assessment.fixationDuration.toFixed(1) + 's' : 'N/A'}</span>
                            </div>
                            ${assessment.notes ? `
                            <div class="detail-row">
                                <span class="detail-label">Notes:</span>
                                <span>${assessment.notes}</span>
                            </div>` : ''}
                        `;
                        
                        // Add toggle functionality
                        toggleBtn.addEventListener('click', function() {
                            const isExpanded = this.dataset.expanded === 'true';
                            if (isExpanded) {
                                details.style.display = 'none';
                                this.textContent = 'Show Details';
                                this.dataset.expanded = 'false';
                            } else {
                                details.style.display = 'block';
                                this.textContent = 'Hide Details';
                                this.dataset.expanded = 'true';
                            }
                        });
                        
                        // Append everything to the list item
                        li.appendChild(summary);
                        li.appendChild(toggleBtn);
                        li.appendChild(details);
                        
                        // Add to report list
                        reportList.appendChild(li);
                    });
                } else {
                    reportList.innerHTML = '<p>No previous assessments found.</p>';
                    document.getElementById('report-container').style.display = 'flex';
                }
                
            } catch (error) {
                console.error('Error loading previous assessments:', error);
            }
        }
        
        // Clear all assessment reports
        async function clearReport() {
            const user = auth.currentUser;
            if (!user) {
                alert('You need to be logged in to clear reports.');
                return;
            }
            
            if (!confirm('Are you sure you want to delete all assessment records? This action cannot be undone.')) {
                return;
            }
            
            try {
                let path;
                
                // Check if this is a patient assessment (doctor viewing patient)
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                const doctorId = sessionStorage.getItem('doctorId');
                
                if (currentPatientId && doctorId) {
                    // This is a doctor viewing a patient
                    console.log(`Clearing patient assessment results - Doctor: ${doctorId}, Patient: ${currentPatientId}`);
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/mirror`;
                } else {
                    // Regular user
                    // Check if user is a doctor
                    const roleSnapshot = await database.ref(`roles/${user.uid}`).once('value');
                    const role = roleSnapshot.val();
                    
                    if (role === 'doctor') {
                        console.log(`Clearing doctor's own assessment results: ${user.uid}`);
                        path = `doctors/${user.uid}/quiz/mirror`;
                    } else {
                        console.log(`Clearing regular user assessment results: ${user.uid}`);
                        path = `users/${user.uid}/quiz/mirror`;
                    }
                }
                
                console.log(`Removing all assessment results from path: ${path}`);
                
                // Remove all data at the specified path
                await database.ref(path).remove();
                
                // Reset the results display
                document.getElementById('report-list').innerHTML = '<p>No previous assessments found.</p>';
                
                alert('All assessment reports have been cleared successfully.');
                
            } catch (error) {
                console.error('Error clearing reports:', error);
                alert('Failed to clear reports: ' + error.message);
            }
        }
        
        // Start eye tracking
        function startEyeTracking() {
            if (!isFaceDetectionInitialized || !enableEyeTracking) return;
            
            // Clear any existing interval
            if (detectionInterval) {
                clearInterval(detectionInterval);
            }
            
            // Setup canvas for drawing
            const videoEl = document.getElementById('camera');
            const canvas = document.getElementById('overlay');
            const displaySize = { width: videoEl.width, height: videoEl.height };
            faceapi.matchDimensions(canvas, displaySize);
            
            // Reset tracking data
            eyeMovementData = [];
            lastEyePosition = { x: 0, y: 0 };
            lastEyeballVector = { x: 0, y: 0 };
            eyeballVectorHistory = [];
            lastFacePosition = { x: 0, y: 0 };
            eyeMovementCount = 0;
            eyeballMovementCount = 0;
            eyeFixationCount = 0;
            eyeFixationDuration = 0;
            lastDetectionTime = Date.now();
            detectionFrameCount = 0;
            isFollowingLight = false;
            followingScore = 0;
            followingHistory = [];
            lightPosition = { x: 0, y: 0 };
            lastLightPosition = { x: 0, y: 0 };
            isCalibrated = false;
            calibrationPoints = [];
            maxEyeballMovement = 1.0;
            eyeballNoiseThreshold = 0.3;
            
            // Start detection loop
            detectionInterval = setInterval(async () => {
                try {
                    if (!videoEl.paused && !videoEl.ended) {
                        // Calculate framerate
                        const now = Date.now();
                        detectionFrameCount++;
                        if (now - lastDetectionTime >= 1000) {
                            frameRate = detectionFrameCount;
                            detectionFrameCount = 0;
                            lastDetectionTime = now;
                        }
                        
                        // Detect faces with landmarks and expressions for better face fitting
                        const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 224, scoreThreshold: 0.5 });
                        const detections = await faceapi.detectSingleFace(videoEl, options)
                            .withFaceLandmarks()
                            .withFaceExpressions();
                        
                        // Clear canvas
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        if (detections) {
                            // Get face position to isolate eyeball movements from face movements
                            const faceBox = detections.detection.box;
                            const currentFacePosition = {
                                x: faceBox.x + faceBox.width/2,
                                y: faceBox.y + faceBox.height/2
                            };
                            
                            // Extract eye landmarks
                            const leftEye = detections.landmarks.getLeftEye();
                            const rightEye = detections.landmarks.getRightEye();
                            
                            // Calculate eye centers
                            const leftEyeCenter = calculateEyeCenter(leftEye);
                            const rightEyeCenter = calculateEyeCenter(rightEye);
                            
                            // Enhanced iris detection with weighted approach to get better pupil estimation
                            const leftIris = calculateEnhancedIrisPosition(leftEye, "left");
                            const rightIris = calculateEnhancedIrisPosition(rightEye, "right");
                            
                            // Calculate eyeball vectors (direction iris is looking relative to eye center)
                            const leftEyeballVector = {
                                x: leftIris.x - leftEyeCenter.x,
                                y: leftIris.y - leftEyeCenter.y
                            };
                            
                            const rightEyeballVector = {
                                x: rightIris.x - rightEyeCenter.x,
                                y: rightIris.y - rightEyeCenter.y
                            };
                            
                            // Check if eyes are closed - more permissive criterion
                            const leftMagnitude = Math.sqrt(leftEyeballVector.x * leftEyeballVector.x + leftEyeballVector.y * leftEyeballVector.y);
                            const rightMagnitude = Math.sqrt(rightEyeballVector.x * rightEyeballVector.x + rightEyeballVector.y * rightEyeballVector.y);
                            // Almost always consider eyes open unless truly tiny vectors
                            const eyesOpen = leftMagnitude > 0.02 || rightMagnitude > 0.02;
                            
                            // Average eyeball vector - only consider if eyes are open
                            const rawAvgEyeballVector = {
                                x: (leftEyeballVector.x + rightEyeballVector.x) / 2,
                                y: (leftEyeballVector.y + rightEyeballVector.y) / 2
                            };
                            
                            // Add to history for smoothing
                            if (eyesOpen) {
                                eyeballVectorHistory.push(rawAvgEyeballVector);
                                // Limit history size
                                if (eyeballVectorHistory.length > EYEBALL_HISTORY_SIZE) {
                                    eyeballVectorHistory.shift();
                                }
                            }
                            
                            // Apply smoothing to reduce noise and improve accuracy
                            const avgEyeballVector = smoothEyeballVector(eyeballVectorHistory);
                            
                            // Draw face landmarks if visual tracking is enabled
                            if (showTrackingVisuals) {
                                // Draw face box with lower opacity to show we're tracking it but it's not the focus
                                ctx.strokeStyle = 'rgba(0, 0, 255, 0.3)';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(faceBox.x, faceBox.y, faceBox.width, faceBox.height);
                                
                                // Draw eye landmarks
                                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                                ctx.beginPath();
                                leftEye.forEach((point, i) => {
                                    if (i === 0) ctx.moveTo(point.x, point.y);
                                    else ctx.lineTo(point.x, point.y);
                                });
                                ctx.closePath();
                                ctx.stroke();
                                
                                ctx.beginPath();
                                rightEye.forEach((point, i) => {
                                    if (i === 0) ctx.moveTo(point.x, point.y);
                                    else ctx.lineTo(point.x, point.y);
                                });
                                ctx.closePath();
                                ctx.stroke();
                                
                                // Highlight eye centers
                                ctx.fillStyle = '#00ff00';
                                ctx.beginPath();
                                ctx.arc(leftEyeCenter.x, leftEyeCenter.y, 2, 0, 2 * Math.PI);
                                ctx.arc(rightEyeCenter.x, rightEyeCenter.y, 2, 0, 2 * Math.PI);
                                ctx.fill();
                                
                                // Highlight iris/pupils
                                ctx.fillStyle = '#ff0000';
                                ctx.beginPath();
                                ctx.arc(leftIris.x, leftIris.y, 3, 0, 2 * Math.PI);
                                ctx.arc(rightIris.x, rightIris.y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                                
                                // Draw eyeball direction vectors
                                ctx.strokeStyle = '#ff00ff';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(leftEyeCenter.x, leftEyeCenter.y);
                                ctx.lineTo(leftEyeCenter.x + leftEyeballVector.x * 3, leftEyeCenter.y + leftEyeballVector.y * 3);
                                ctx.moveTo(rightEyeCenter.x, rightEyeCenter.y);
                                ctx.lineTo(rightEyeCenter.x + rightEyeballVector.x * 3, rightEyeCenter.y + rightEyeballVector.y * 3);
                                ctx.stroke();
                            }
                            
                            // Calculate average eye position
                            const avgEyePos = {
                                x: (leftEyeCenter.x + rightEyeCenter.x) / 2,
                                y: (leftEyeCenter.y + rightEyeCenter.y) / 2
                            };
                            
                            // Check for overall face movement
                            const faceMovementThreshold = 5; // pixels
                            const faceMovement = Math.sqrt(
                                Math.pow(currentFacePosition.x - lastFacePosition.x, 2) + 
                                Math.pow(currentFacePosition.y - lastFacePosition.y, 2)
                            );
                            
                            // Auto-calibrate eyeball movement threshold with much more leeway
                            if (eyesOpen && eyeballVectorHistory.length >= 2) { // Only need 2 frames now
                                const currMagnitude = Math.sqrt(
                                    avgEyeballVector.x * avgEyeballVector.x + 
                                    avgEyeballVector.y * avgEyeballVector.y
                                );
                                
                                // Update maximum observed eyeball movement with higher cap
                                if (currMagnitude > maxEyeballMovement && currMagnitude < 15) { // Higher cap for greater range
                                    maxEyeballMovement = currMagnitude;
                                    // Keep threshold very low to detect subtle movements
                                    eyeballNoiseThreshold = Math.max(0.05, maxEyeballMovement * 0.05); // Only 5% of max for greater sensitivity
                                }
                            }
                            
                            // Calculate eyeball movement with dynamically calibrated threshold
                            const eyeballMovement = Math.sqrt(
                                Math.pow(avgEyeballVector.x - lastEyeballVector.x, 2) + 
                                Math.pow(avgEyeballVector.y - lastEyeballVector.y, 2)
                            );
                            
                            // Get light stimulus position with improved accuracy
                            const lightStimulus = document.getElementById('lightStimulus');
                            const lightRect = lightStimulus.getBoundingClientRect();
                            const videoRect = videoEl.getBoundingClientRect();
                            
                            // Convert to canvas coordinates with proper scaling
                            const canvasLightPos = {
                                x: ((lightRect.left + lightRect.width/2) - videoRect.left) * (canvas.width / videoRect.width),
                                y: ((lightRect.top + lightRect.height/2) - videoRect.top) * (canvas.height / videoRect.height)
                            };
                            
                            // Store light position change for movement detection
                            const lightMovement = {
                                x: canvasLightPos.x - lastLightPosition.x,
                                y: canvasLightPos.y - lastLightPosition.y
                            };
                            const lightMoved = Math.sqrt(lightMovement.x * lightMovement.x + lightMovement.y * lightMovement.y) > 2;
                            lastLightPosition = { ...canvasLightPos };
                            lightPosition = { ...canvasLightPos };
                            
                            // Check if eyes are looking toward light stimulus
                            const eyesToLightVector = {
                                x: canvasLightPos.x - avgEyePos.x,
                                y: canvasLightPos.y - avgEyePos.y
                            };
                            
                            // Normalize vectors
                            const normalizeVector = (vector) => {
                                const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                                return magnitude === 0 ? vector : { 
                                    x: vector.x / magnitude, 
                                    y: vector.y / magnitude 
                                };
                            };
                            
                            const normEyeballVector = normalizeVector(avgEyeballVector);
                            const normLightVector = normalizeVector(eyesToLightVector);
                            
                            // Dot product to calculate similarity of direction (1 = same direction, -1 = opposite)
                            const dotProduct = normEyeballVector.x * normLightVector.x + normEyeballVector.y * normLightVector.y;
                            
                            // GREATLY simplified light following detection with more leeway
                            let followingDetected = false;
                            
                            // Much lower dot product threshold (was 0.6-0.7, now 0.3)
                            followingDetected = dotProduct > 0.3;
                            
                            // Additional methods to increase detection rates
                            if (!followingDetected) {
                                // Try alternate detection: is eyeball pointing roughly in same quadrant as light?
                                const eyeQuadrant = getQuadrant(avgEyeballVector);
                                const lightQuadrant = getQuadrant(eyesToLightVector);
                                
                                // Consider following if pointing in same or adjacent quadrant
                                if (eyeQuadrant === lightQuadrant || areAdjacentQuadrants(eyeQuadrant, lightQuadrant)) {
                                    followingDetected = true;
                                }
                                
                                // Also check if eye movement vector is pointing in general light direction
                                if (lastEyeballVector.x !== 0) {
                                    const eyeMovementVector = {
                                        x: avgEyeballVector.x - lastEyeballVector.x,
                                        y: avgEyeballVector.y - lastEyeballVector.y
                                    };
                                    
                                    const eyeMoveMagnitude = Math.sqrt(
                                        eyeMovementVector.x * eyeMovementVector.x +
                                        eyeMovementVector.y * eyeMovementVector.y
                                    );
                                    
                                    // If significant eye movement occurred
                                    if (eyeMoveMagnitude > 0.05) {
                                        const normEyeMovement = normalizeVector(eyeMovementVector);
                                        const moveToLightAlignment = normEyeMovement.x * normLightVector.x +
                                                                    normEyeMovement.y * normLightVector.y;
                                        
                                        // Very permissive threshold - just need to be vaguely in the right direction
                                        if (moveToLightAlignment > 0.1) {
                                            followingDetected = true;
                                        }
                                    }
                                }
                            }
                            
                            // Update following score (sliding window for more stability)
                            followingHistory.push(followingDetected ? 1 : 0);
                            if (followingHistory.length > FOLLOWING_HISTORY_SIZE) {
                                followingHistory.shift();
                            }
                            
                            // Calculate weighted score that prioritizes recent frames
                            const weightedFollowingScore = calculateWeightedScore(followingHistory);
                            followingScore = weightedFollowingScore;
                            
                            // Much lower threshold for considering following (was 0.5)
                            isFollowingLight = followingScore > 0.3;
                            
                            // Draw line from eye to light if following
                            if (showTrackingVisuals && isFollowingLight) {
                                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([5, 3]);
                                ctx.beginPath();
                                ctx.moveTo(avgEyePos.x, avgEyePos.y);
                                ctx.lineTo(canvasLightPos.x, canvasLightPos.y);
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }
                            
                            // Much more permissive criteria for counting eyeball movements
                            // Allow some face movement and very small eyeball movements
                            if (faceMovement < faceMovementThreshold * 2 && eyeballMovement > eyeballNoiseThreshold * 0.5) { // Double face threshold, halve eyeball threshold
                                // Eyeball movement detected (independent of face)
                                eyeballMovementCount++;
                                eyeFixationCount = 0; // Reset fixation counter
                                
                                // Draw eyeball movement path if visual tracking is enabled
                                if (showTrackingVisuals && lastEyeballVector.x !== 0) {
                                    ctx.strokeStyle = '#ff0000';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.moveTo(avgEyePos.x, avgEyePos.y);
                                    ctx.lineTo(avgEyePos.x + avgEyeballVector.x * 5, avgEyePos.y + avgEyeballVector.y * 5);
                                    ctx.stroke();
                                }
                                
                                // Record eyeball movement data
                                eyeMovementData.push({
                                    timestamp: Date.now(),
                                    position: { ...avgEyePos },
                                    eyeballVector: { ...avgEyeballVector },
                                    isMovement: true,
                                    followingLight: isFollowingLight
                                });
                            } else if (faceMovement >= faceMovementThreshold) {
                                // Face movement detected, but not counting as eyeball movement
                                eyeMovementCount++;
                            } else {
                                // Eye fixation detected
                                eyeFixationCount++;
                                if (eyeFixationCount >= 5) { // About 0.25 seconds at 20fps
                                    eyeFixationDuration += 1/frameRate;
                                    
                                    // Mark fixation point if visual tracking is enabled
                                    if (showTrackingVisuals) {
                                        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                                        ctx.beginPath();
                                        ctx.arc(avgEyePos.x, avgEyePos.y, 5, 0, 2 * Math.PI);
                                        ctx.fill();
                                    }
                                    
                                    // Record eye fixation data
                                    eyeMovementData.push({
                                        timestamp: Date.now(),
                                        position: { ...avgEyePos },
                                        eyeballVector: { ...avgEyeballVector },
                                        isMovement: false,
                                        fixationDuration: eyeFixationDuration,
                                        followingLight: isFollowingLight
                                    });
                                }
                            }
                            
                            // Update last positions
                            lastEyePosition = { ...avgEyePos };
                            lastEyeballVector = { ...avgEyeballVector };
                            lastFacePosition = { ...currentFacePosition };
                            
                            // Enhanced detection data display with calibration info
                            document.getElementById('detectionData').innerHTML = `
                                Face movements: ${eyeMovementCount}<br>
                                <b>Eyeball movements: ${eyeballMovementCount}</b><br>
                                Following light: ${isFollowingLight ? '<span style="color:green">Yes</span>' : 'No'} (${(followingScore * 100).toFixed(0)}%)<br>
                                Fixation: ${eyeFixationDuration.toFixed(1)}s<br>
                                ${eyesOpen ? '<span style="color:green">Eyes open</span>' : '<span style="color:red">Eyes closed</span>'}<br>
                                Threshold: ${eyeballNoiseThreshold.toFixed(2)}<br>
                                FPS: ${frameRate}
                            `;
                            
                            // Automatically check the observation checkboxes based on detection
                            if (eyeFixationDuration > 2) {
                                document.getElementById('fixation').checked = true;
                            }
                            
                            // Automatically check field response boxes based on light tracking
                            if (isFollowingLight && canvasLightPos.x < canvas.width / 3) {
                                document.getElementById('leftField').checked = true;
                            }
                            if (isFollowingLight && canvasLightPos.x > canvas.width * 2 / 3) {
                                document.getElementById('rightField').checked = true;
                            }
                            if (isFollowingLight && canvasLightPos.x >= canvas.width / 3 && canvasLightPos.x <= canvas.width * 2 / 3) {
                                document.getElementById('centerField').checked = true;
                            }
                            
                            // Set eye contact duration field
                            document.getElementById('duration').value = Math.round(eyeFixationDuration);
                        } else {
                            document.getElementById('detectionData').textContent = 'No face detected';
                        }
                    }
                } catch (error) {
                    console.error('Error in eye tracking:', error);
                }
            }, 50); // 20 fps
        }
        
        // Stop eye tracking
        function stopEyeTracking() {
            if (detectionInterval) {
                clearInterval(detectionInterval);
                detectionInterval = null;
            }
            document.getElementById('detectionData').textContent = 'Eye tracking disabled';
            
            // Clear overlay canvas
            const canvas = document.getElementById('overlay');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Calculate eye center from landmarks
        function calculateEyeCenter(eyePoints) {
            let sumX = 0;
            let sumY = 0;
            
            for (let i = 0; i < eyePoints.length; i++) {
                sumX += eyePoints[i].x;
                sumY += eyePoints[i].y;
            }
            
            return {
                x: sumX / eyePoints.length,
                y: sumY / eyePoints.length
            };
        }
        
        // Simplified iris position calculation that exaggerates movements for better detection
        function calculateEnhancedIrisPosition(eyePoints, eyeSide) {
            // Use all eye landmarks with simple weighting
            const centerX = eyePoints.reduce((sum, p) => sum + p.x, 0) / eyePoints.length;
            const centerY = eyePoints.reduce((sum, p) => sum + p.y, 0) / eyePoints.length;
            
            // Find the inner and outer corners (usually at indices 0 and 3)
            const innerCornerIdx = eyeSide === "left" ? 3 : 0;
            const outerCornerIdx = eyeSide === "left" ? 0 : 3;
            
            // Top and bottom points (usually indices 1 and 2 or 4 and 5)
            const topIdx = eyeSide === "left" ? 1 : 4;
            const bottomIdx = eyeSide === "left" ? 2 : 5;
            
            // Get eye dimensions
            const eyeWidth = Math.abs(eyePoints[outerCornerIdx].x - eyePoints[innerCornerIdx].x);
            const eyeHeight = Math.abs(eyePoints[topIdx].y - eyePoints[bottomIdx].y);
            
            // Use a central point biased toward inner corner for better iris estimation
            let irisX;
            let irisY;
            
            if (eyeSide === "left") {
                // Left eye - bias toward inner (right) corner
                irisX = centerX + eyeWidth * 0.1; // Slight bias right
                irisY = centerY;
            } else {
                // Right eye - bias toward inner (left) corner
                irisX = centerX - eyeWidth * 0.1; // Slight bias left
                irisY = centerY;
            }
            
            // Exaggerate iris position using eye gaze approximation based on eye shape
            const topBottomDiff = eyePoints[topIdx].y - eyePoints[bottomIdx].y;
            const innerOuterDiff = eyePoints[innerCornerIdx].x - eyePoints[outerCornerIdx].x;
            
            // Exaggerate up/down position variation
            if (Math.abs(topBottomDiff) > 0.2 * eyeHeight) {
                const verticalFactor = 0.2 * Math.sign(topBottomDiff) * eyeHeight;
                irisY += verticalFactor;
            }
            
            // Exaggerate left/right position variation
            if (Math.abs(innerOuterDiff) > 0.1 * eyeWidth) {
                const horizontalFactor = 0.25 * Math.sign(innerOuterDiff) * eyeWidth;
                irisX += horizontalFactor;
            }
            
            return { x: irisX, y: irisY };
        }
        
        // Get eye width helper function
        function getEyeWidth(eyePoints) {
            // Typically points 0 and 3 are the outer and inner corners
            const leftX = Math.min(...eyePoints.map(p => p.x));
            const rightX = Math.max(...eyePoints.map(p => p.x));
            return rightX - leftX;
        }
        
        // Get eye height helper function
        function getEyeHeight(eyePoints) {
            // Typically points 1, 2 are top and bottom of eye
            const topY = Math.min(...eyePoints.map(p => p.y));
            const bottomY = Math.max(...eyePoints.map(p => p.y));
            return bottomY - topY;
        }
        
        // Less aggressive smoothing to preserve more of the original movement
        function smoothEyeballVector(history) {
            if (history.length === 0) return { x: 0, y: 0 };
            if (history.length === 1) return history[0]; // Don't smooth single entries
            
            // If only 2-3 entries, just take most recent one with slight averaging
            if (history.length <= 3) {
                const latest = history[history.length-1];
                const prev = history[history.length-2];
                
                // 80% current, 20% previous - preserves more movement
                return {
                    x: latest.x * 0.8 + prev.x * 0.2,
                    y: latest.y * 0.8 + prev.y * 0.2
                };
            }
            
            // For longer history, use simplified weighting that preserves more of recent movements
            // The most recent entry gets 60% weight, rest is averaged
            const latest = history[history.length-1];
            
            let sumX = 0;
            let sumY = 0;
            
            // Average previous entries (excluding latest)
            for (let i = 0; i < history.length-1; i++) {
                sumX += history[i].x;
                sumY += history[i].y;
            }
            
            const avgPrevious = {
                x: sumX / (history.length-1),
                y: sumY / (history.length-1)
            };
            
            // Combine with heavy weighting to latest (60/40 split)
            return {
                x: latest.x * 0.6 + avgPrevious.x * 0.4,
                y: latest.y * 0.6 + avgPrevious.y * 0.4
            };
        }
        
        // Get quadrant helper function (1-4, clockwise from top-right)
        function getQuadrant(vector) {
            if (vector.x >= 0 && vector.y < 0) return 1; // top-right
            if (vector.x >= 0 && vector.y >= 0) return 2; // bottom-right
            if (vector.x < 0 && vector.y >= 0) return 3; // bottom-left
            return 4; // top-left
        }
        
        // Check if quadrants are adjacent
        function areAdjacentQuadrants(q1, q2) {
            if (Math.abs(q1 - q2) === 1) return true; // adjacent normally
            if ((q1 === 1 && q2 === 4) || (q1 === 4 && q2 === 1)) return true; // wrap around
            return false;
        }
        
        // Calculate weighted score for following detection
        function calculateWeightedScore(history) {
            if (history.length === 0) return 0;
            
            let sumScore = 0;
            let sumWeights = 0;
            
            for (let i = 0; i < history.length; i++) {
                // More recent entries get exponentially higher weight
                const weight = Math.pow(1.5, i) / Math.pow(1.5, history.length - 1);
                sumScore += history[i] * weight;
                sumWeights += weight;
            }
            
            return sumScore / sumWeights;
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', function() {
            stopEyeTracking();
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
