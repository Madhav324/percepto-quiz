<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Reports - Percepto</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 15px;
        }

        .container {
            text-align: center;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 650px;
            padding: 20px;
            position: relative;
        }

        /* Header and profile styles */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        h1 {
            font-size: 22px;
            color: #333;
            margin: 0;
        }
        
        h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }

        /* Profile Navigation Styles */
        .profile-dropdown {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            z-index: 100;
        }
        
        .profile-icon {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 101;
            font-size: 14px;
        }
        
        .profile-icon:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        /* Profile Menu */
        .profile-menu {
            position: absolute;
            top: 45px;
            right: 0;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            min-width: 160px;
            z-index: 102;
            display: none;
            overflow: hidden;
        }
        
        .profile-menu.active {
            display: block;
        }
        
        .profile-menu a {
            padding: 10px 12px;
            display: block;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            color: #333;
            text-decoration: none;
            font-size: 14px;
        }
        
        .profile-menu a:hover {
            background-color: #f5f5f5;
        }
        
        /* Report styles */
        .report-container {
            text-align: left;
            padding: 5px 0;
        }
        
        .report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .home-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            padding: 6px 12px;
            text-decoration: none;
            display: inline-block;
            transition: background-color 0.3s;
        }
        
        .home-btn:hover {
            background-color: #45a049;
        }
        
        .quiz-report {
            background-color: #f9f9f9;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        
        .quiz-report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .quiz-report:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        
        .quiz-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .quiz-date {
            font-size: 12px;
            color: #777;
        }
        
        .toggle-details {
            font-size: 11px;
            color: #4CAF50;
            cursor: pointer;
            text-decoration: underline;
            margin-top: 5px;
            display: inline-block;
        }
        
        .quiz-details {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dashed #ddd;
            display: none;
        }
        
        .quiz-details.active {
            display: block;
        }
        
        .raw-data {
            margin: 10px 0;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-bottom: 10px;
        }
        
        .stats-table td {
            padding: 5px 8px;
            border-bottom: 1px solid #eee;
        }
        
        .stats-table tr:nth-child(even) {
            background-color: #f5f5f5;
        }
        
        .stats-table td:first-child {
            font-weight: 500;
            text-transform: capitalize;
            width: 50%;
        }
        
        .stats-table td:last-child {
            text-align: right;
            font-weight: bold;
            color: #333;
        }
        
        .progress-container {
            height: 4px;
            background-color: #e0e0e0;
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
        }
        
        .attempt-history {
            font-size: 12px;
            margin-top: 10px;
        }
        
        .quiz-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 5px;
            margin-top: 10px;
        }
        
        .stat {
            background-color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
            border: 1px solid #eee;
        }
        
        .stat-value {
            font-weight: bold;
            color: #4CAF50;
            font-size: 15px;
            margin-bottom: 3px;
        }
        
        .stat-label {
            color: #777;
            font-size: 11px;
        }
        
        .loading {
            text-align: center;
            padding: 30px;
            color: #777;
        }
        
        .no-data {
            text-align: center;
            padding: 30px;
            color: #777;
            background-color: #f9f9f9;
            border-radius: 6px;
            margin-top: 15px;
        }
        
        .user-name {
            font-size: 15px;
            color: #333;
            margin-right: 8px;
        }
        
        .patient-indicator {
            display: inline-block;
            background-color: #e9f5e9;
            color: #4CAF50;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }
        
        /* Score pills */
        .score-pill {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .score-high {
            background-color: #e6f7e6;
            color: #2e7d32;
        }
        
        .score-medium {
            background-color: #fff8e1;
            color: #ff8f00;
        }
        
        .score-low {
            background-color: #ffebee;
            color: #c62828;
        }
        
        /* CVI Risk Classification Styles */
        .cvi-risk-container {
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        
        .cvi-risk-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .cvi-risk-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .cvi-risk-quiz {
            font-weight: 500;
            color: #333;
        }
        
        .cvi-risk-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            margin: 2px;
        }
        
        .cvi-risk-low {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .cvi-risk-medium {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .cvi-risk-high {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .cvi-overall-risk {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }
        
        .cvi-overall-low {
            background-color: #e8f5e8;
            color: #2e7d32;
            border: 2px solid #66bb6a;
        }
        
        .cvi-overall-medium {
            background-color: #fef9e7;
            color: #8a6d3b;
            border: 2px solid #f0ad4e;
        }
        
        .cvi-overall-high {
            background-color: #f2dede;
            color: #a94442;
            border: 2px solid #d9534f;
        }
        
        /* Data Analysis Styles */
        .data-analysis-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .analysis-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .btn-primary, .btn-secondary {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #5a6fd8, #6a4190);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #e081e9, #e3455a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }
        
        .quiz-analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .quiz-analysis-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #dee2e6;
            transition: all 0.3s ease;
        }
        
        .quiz-analysis-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border-color: #667eea;
        }
        
        .quiz-analysis-card h3 {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 700;
        }
        
        .stats-summary {
            font-size: 14px;
            line-height: 1.6;
        }
        
        .stat-group {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        
        .stat-group h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 16px;
            font-weight: 600;
        }
        
        .stat-group p {
            margin: 5px 0;
            color: #6c757d;
        }
        
        .threshold-recommendation {
            background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            border-left: 3px solid #2196f3;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .threshold-recommendation strong {
            color: #1976d2;
            display: block;
            margin-bottom: 5px;
        }
        
        .analysis-summary {
            background: linear-gradient(135deg, #fff3e0, #f3e5f5);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 2px solid #ff9800;
        }
        
        .analysis-summary h3 {
            color: #e65100;
            margin: 0 0 15px 0;
        }
        
        .analysis-summary ul {
            margin: 15px 0;
            padding-left: 20px;
        }
        
        .analysis-summary li {
            margin: 8px 0;
            color: #5d4037;
        }
        
        .data-analysis-trigger {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, #e8f5e8, #f0f8ff);
            border-radius: 12px;
            border: 2px dashed #4caf50;
        }
        
        .data-analysis-trigger h3 {
            color: #2e7d32;
            margin: 0 0 10px 0;
        }
        
        .data-analysis-trigger p {
            color: #388e3c;
            margin: 0 0 15px 0;
        }
        
        /* Enhanced Analysis Styles */
            .analysis-results .quiz-card.attention-needed {
                border-left: 4px solid #ff6b6b;
                background: linear-gradient(135deg, #fff5f5 0%, #ffffff 100%);
            }
            
            /* Adaptive Analysis Styling */
            .data-analysis-trigger {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 25px;
                border-radius: 15px;
                margin: 20px 0;
                box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
            }
            
            .data-analysis-trigger h3 {
                margin: 0 0 10px 0;
                font-size: 1.4em;
            }
            
            .analysis-options {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin: 20px 0;
            }
            
            .analysis-option {
                background: rgba(255, 255, 255, 0.1);
                padding: 20px;
                border-radius: 10px;
                border: 2px solid rgba(255, 255, 255, 0.2);
                transition: all 0.3s ease;
            }
            
            .analysis-option:hover {
                background: rgba(255, 255, 255, 0.2);
                border-color: rgba(255, 255, 255, 0.4);
                transform: translateY(-2px);
            }
            
            .analysis-option.recommended {
                border-color: #ffd700;
                background: rgba(255, 215, 0, 0.1);
                position: relative;
            }
            
            .analysis-option.recommended::before {
                content: "⭐ RECOMMENDED";
                position: absolute;
                top: -10px;
                right: 10px;
                background: #ffd700;
                color: #333;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 0.7em;
                font-weight: bold;
            }
            
            .analysis-option h4 {
                margin: 0 0 10px 0;
                font-size: 1.1em;
            }
            
            .analysis-option p {
                margin: 0 0 15px 0;
                opacity: 0.9;
                font-size: 0.9em;
            }
            
            .existing-standards {
                background: rgba(255, 255, 255, 0.1);
                padding: 20px;
                border-radius: 10px;
                border: 2px solid rgba(76, 175, 80, 0.5);
                margin-top: 20px;
            }
            
            .existing-standards h4 {
                margin: 0 0 10px 0;
                color: #4caf50;
            }
            
            /* Adaptive Analysis Results */
            .adaptive-analysis-section {
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
                padding: 30px;
                border-radius: 15px;
                margin: 20px 0;
            }
            
            .adaptive-analysis-section h2 {
                text-align: center;
                margin: 0 0 30px 0;
                color: #2c3e50;
                font-size: 2em;
            }
            
            .analysis-overview {
                margin-bottom: 30px;
            }
            
            .overview-stats {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 20px;
                margin: 20px 0;
            }
            
            .stat-card {
                background: white;
                padding: 20px;
                border-radius: 10px;
                text-align: center;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
                border: 2px solid #e3f2fd;
            }
            
            .stat-card h3 {
                margin: 0 0 10px 0;
                font-size: 2em;
                color: #1976d2;
            }
            
            .stat-card p {
                margin: 0;
                color: #666;
                font-weight: 500;
            }
            
            .analysis-controls {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin: 20px 0;
                flex-wrap: wrap;
            }
            
            .adaptive-quiz-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
                gap: 25px;
                margin: 30px 0;
            }
            
            .adaptive-quiz-card {
                background: white;
                border-radius: 15px;
                padding: 25px;
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
                border: 3px solid #e0e0e0;
                transition: all 0.3s ease;
            }
            
            .adaptive-quiz-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
            }
            
            .adaptive-quiz-card.high-quality {
                border-color: #4caf50;
                background: linear-gradient(135deg, #f1f8e9 0%, #ffffff 100%);
            }
            
            .adaptive-quiz-card.medium-quality {
                border-color: #ff9800;
                background: linear-gradient(135deg, #fff8e1 0%, #ffffff 100%);
            }
            
            .adaptive-quiz-card.low-quality {
                border-color: #f44336;
                background: linear-gradient(135deg, #ffebee 0%, #ffffff 100%);
            }
            
            .adaptive-quiz-card h3 {
                margin: 0 0 20px 0;
                color: #2c3e50;
                font-size: 1.3em;
                border-bottom: 2px solid #ecf0f1;
                padding-bottom: 10px;
            }
            
            .adaptive-stats-summary {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            
            .data-quality-info {
                background: #f8f9fa;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .data-quality-info p {
                margin: 5px 0;
                font-size: 0.9em;
            }
            
            .performance-distribution {
                margin: 20px 0;
            }
            
            .performance-distribution h4 {
                margin: 0 0 15px 0;
                color: #34495e;
            }
            
            .distribution-bars {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .dist-bar {
                height: 25px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 10px;
                color: white;
                font-size: 0.8em;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
                min-width: 120px;
            }
            
            .dist-bar.excellent { background: linear-gradient(90deg, #4caf50, #66bb6a); }
            .dist-bar.optimal { background: linear-gradient(90deg, #8bc34a, #9ccc65); }
            .dist-bar.low-risk { background: linear-gradient(90deg, #2196f3, #42a5f5); }
            .dist-bar.medium-risk { background: linear-gradient(90deg, #ff9800, #ffb74d); }
            .dist-bar.high-risk { background: linear-gradient(90deg, #f44336, #ef5350); }
            
            .adaptive-stat-group {
                margin: 20px 0;
                padding: 15px;
                background: #f8f9fa;
                border-radius: 8px;
                border-left: 4px solid #3498db;
            }
            
            .adaptive-stat-group h4 {
                margin: 0 0 15px 0;
                color: #2c3e50;
            }
            
            .threshold-display {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-bottom: 10px;
            }
            
            .threshold-item {
                padding: 8px 12px;
                border-radius: 6px;
                font-weight: 500;
                font-size: 0.9em;
            }
            
            .threshold-item.high-risk {
                background: #ffebee;
                color: #c62828;
                border-left: 4px solid #f44336;
            }
            
            .threshold-item.medium-risk {
                background: #fff8e1;
                color: #ef6c00;
                border-left: 4px solid #ff9800;
            }
            
            .threshold-item.low-risk {
                background: #f1f8e9;
                color: #2e7d32;
                border-left: 4px solid #4caf50;
            }
            
            .stats-detail {
                font-size: 0.8em;
                color: #666;
                margin: 10px 0 0 0;
                font-style: italic;
            }
            
            .data-insights {
                background: #e3f2fd;
                padding: 15px;
                border-radius: 8px;
                margin: 20px 0;
            }
            
            .data-insights h4 {
                margin: 0 0 10px 0;
                color: #1976d2;
            }
            
            .data-insights ul {
                margin: 0;
                padding-left: 20px;
            }
            
            .data-insights li {
                margin: 5px 0;
                font-size: 0.9em;
            }
            
            .adaptive-summary {
                background: white;
                padding: 30px;
                border-radius: 15px;
                margin: 30px 0;
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
                border: 2px solid #e3f2fd;
            }
            
            .adaptive-summary h3 {
                color: #1976d2;
                margin: 0 0 20px 0;
                text-align: center;
            }
            
            .methodology-explanation, .confidence-explanation {
                margin: 25px 0;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 10px;
                border-left: 4px solid #3498db;
            }
            
            .methodology-explanation h4, .confidence-explanation h4 {
                margin: 0 0 15px 0;
                color: #2c3e50;
            }
            
            .methodology-explanation ul, .confidence-explanation ul {
                margin: 0;
                padding-left: 20px;
            }
            
            .methodology-explanation li, .confidence-explanation li {
                margin: 8px 0;
                line-height: 1.5;
            }
            
            .apply-instruction {
                background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
                color: white;
                padding: 20px;
                border-radius: 10px;
                text-align: center;
                margin: 25px 0;
                font-size: 1.1em;
            }
            
            /* Mobile Responsive */
            @media (max-width: 768px) {
                .analysis-options {
                    grid-template-columns: 1fr;
                }
                
                .adaptive-quiz-grid {
                    grid-template-columns: 1fr;
                }
                
                .overview-stats {
                    grid-template-columns: repeat(2, 1fr);
                }
                
                .analysis-controls {
                    flex-direction: column;
                    align-items: center;
                }
                
                .threshold-display {
                    gap: 6px;
                }
                
                .dist-bar {
                    font-size: 0.7em;
                    height: 20px;
                }
            }      
        .quiz-analysis-card.needs-attention h3 {
            color: #e65100;
        }
        
        .current-vs-recommended {
            margin-top: 15px;
            border-top: 1px solid #e0e0e0;
            padding-top: 12px;
        }
        
        .current-thresholds {
            background: #f5f5f5;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 13px;
            border-left: 3px solid #9e9e9e;
        }
        
        .threshold-recommendation.needs-adjustment {
            background: linear-gradient(135deg, #ffebee, #fff3e0);
            border-left-color: #ff5722;
        }
        
        .threshold-recommendation.good-fit {
            background: linear-gradient(135deg, #e8f5e8, #f3e5f5);
            border-left-color: #4caf50;
        }
        
        .adjustment-needed {
            color: #d84315;
            font-weight: 600;
        }
        
        .good-fit-text {
            color: #2e7d32;
            font-weight: 600;
        }
        
        .threshold-recommendation small {
            color: #666;
            font-style: italic;
        }
        
        /* Responsive design */
        @media (max-width: 576px) {
            .container {
                padding: 15px;
            }
            
            .header {
                flex-direction: column;
                gap: 10px;
            }
            
            .quiz-stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stat {
                padding: 5px;
                min-height: 60px;
                display: flex;
                flex-direction: column;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Quiz Reports</h1>
            <div class="profile-dropdown">
                <span id="userName" class="user-name">User</span>
                <div class="profile-icon" id="profileIcon" onclick="toggleProfileMenu()">U</div>
                <div class="profile-menu" id="profileMenu">
                    <a href="index.html">Home</a>
                    <a href="#" onclick="editProfile()">Edit Profile</a>
                    <a href="#" onclick="logout()">Logout</a>
                </div>
            </div>
        </div>
        
        <div id="patient-indicator-container" style="text-align: right; margin-bottom: 10px; display: none;">
            <span id="patient-indicator" class="patient-indicator">Patient</span>
        </div>

        <div class="report-header">
            <h2>Your Quiz Results</h2>
            <a href="index.html" style="text-decoration: none;"><button>Return</button></a>
            <button id="refresh-btn" class="home-btn" onclick="loadQuizReports()">Refresh</button>
        </div>

        <div class="report-container" id="report-container">
            <div class="loading" id="loading-message">
                Loading your quiz reports...
            </div>
        </div>
        
        <!-- Firebase Scripts -->
        <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
        
        <script>
            // Firebase configuration
            const firebaseConfig = {
                apiKey: "AIzaSyDFENL5Z_2Cewh4p6zp_BZtxL9n0di-9u8",
                authDomain: "projeccvi.firebaseapp.com",
                projectId: "projeccvi",
                storageBucket: "projeccvi.appspot.com",
                messagingSenderId: "279067566247",
                appId: "1:279067566247:web:9cf00f7bf1ea3549fabb82"
            };

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);
            const auth = firebase.auth();
            const database = firebase.database();
            const firestore = firebase.firestore();
            
            // Get quiz context from session storage
            const currentPatientId = sessionStorage.getItem('currentPatientId');
            const doctorId = sessionStorage.getItem('doctorId');
            const isPatientQuiz = !!currentPatientId;
            
            // Quiz type mapping
            const quizNames = {
                'mirror': 'Fixation to Mirror',
                'VDT1': 'Visual Discrimination - Shapes 1',
                'VDT2': 'Visual Discrimination - Shapes 2',
                'VDTS1': 'Visual Discrimination - Size',
                'VDTSE1': 'Visual Discrimination - Emotions',
                'VDTCC1': 'Visual Discrimination - Colors',
                'VC1': 'Visual Closure - Puzzle',
                'VC2': 'Visual Closure - Matching',
                'VC3': 'Visual Closure - Animal',
                'VFC11': 'Visual Form Constancy- Numbers(lv1)',
                'VFC12': 'Visual Form Constancy- Letters(lv1)',
                'VFC13': 'Visual Form Constancy- Size(lv1)',
                'VFC21': 'Visual Form Constancy- Numbers(lv2)',
                'VFC22': 'Visual Form Constancy- Letters(lv2)',
                'VFC23': 'Visual Form Constancy- Size(lv2)',
                'FG': 'Visual Figure Ground',
                'VSpac1': 'Visual Spatial - Level 1',
                'VSpac2': 'Visual Spatial - Level 2',
                'VN1': 'Visual Neglect(lv1)',
                'VN2': 'Visual Neglect(lv2)',
                'morning': 'Visual Sequential Memory - Morning',
                'dressing': 'Visual Sequential Memory - Dressing',
                'lion': 'Visual Sequential Memory - Lion',
                'crow': 'Visual Sequential Memory - Crow',
                'beads': 'Visual Sequential Memory - Beads',
                'morning': 'Morning Routine Assessment',
                'VM1': 'Visual Memory',
                'motion': 'Motion Perception'
            };
            
            // Toggle profile menu
            function toggleProfileMenu() {
                const menu = document.getElementById('profileMenu');
                menu.classList.toggle('active');
            }
            
            // Handle click outside profile menu
            document.addEventListener('click', function(event) {
                const profileIcon = document.getElementById('profileIcon');
                const profileMenu = document.getElementById('profileMenu');
                
                if (!profileIcon.contains(event.target) && !profileMenu.contains(event.target)) {
                    profileMenu.classList.remove('active');
                }
            });
            
            // Format date
            function formatDate(timestamp) {
                if (!timestamp) return 'Unknown date';
                
                const date = new Date(timestamp);
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            // Toggle quiz details visibility
            function toggleQuizDetails(quizType) {
                const detailsElement = document.getElementById(`quiz-details-${quizType}`);
                const toggleIcon = document.getElementById(`toggle-icon-${quizType}`);
                
                if (detailsElement.classList.contains('active')) {
                    detailsElement.classList.remove('active');
                    toggleIcon.textContent = '+';
                } else {
                    detailsElement.classList.add('active');
                    toggleIcon.textContent = '−';
                }
            }
            
            // Get score class based on value
            function getScoreClass(score) {
                if (score >= 80) return 'score-high';
                if (score >= 60) return 'score-medium';
                return 'score-low';
            }
            
            // Enhanced Tailored CVI Risk Assessment - Individual Quiz-Specific Logic
            function calculateCVIRisk(quizType, attempt) {
                if (!attempt) return 'medium';
                
                // Extract comprehensive performance metrics
                const score = attempt.score || 0;
                const timeSpent = (attempt.timeSpent || 0) / 1000;
                const accuracy = attempt.accuracy || 0;
                const totalTaps = attempt.totalTaps || attempt.totalClicks || 0;
                const incorrectAnswers = attempt.incorrectAnswers || 0;
                const correctAnswers = attempt.correctAnswers || 0;
                const avgTime = attempt.avgTime || 0;
                const firstTap = attempt.firstTap || 0;
                
                // Individual quiz-specific tailored assessment
                switch(quizType) {
                    // Mirror Fixation - Most Critical CVI Indicator
                    case 'mirror':
                        return assessMirrorFixationTailored(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Visual Memory Assessments
                    case 'VM1':
                        return assessVisualMemoryVM1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VSM':
                        return assessVisualSequentialMemory(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Visual Closure Assessments - Each Level Tailored
                    case 'VC1':
                        return assessVisualClosurePuzzle(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VC2':
                        return assessVisualClosureMatching(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VC3':
                        return assessVisualClosureAnimal(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VC4':
                        return assessVisualClosureComplex(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Visual Discrimination - Type-Specific
                    case 'VD':
                    case 'VDT1':
                        return assessVisualDiscriminationShapes1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VDT2':
                        return assessVisualDiscriminationShapes2(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VDTS1':
                        return assessVisualDiscriminationSize(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VDTSE1':
                        return assessVisualDiscriminationEmotions(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VDTC':
                    case 'VDTCC1':
                        return assessVisualDiscriminationColors(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Visual Form Constancy - Level and Type Specific
                    case 'VFC11':
                        return assessFormConstancyNumbersL1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VFC12':
                        return assessFormConstancyLettersL1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VFC13':
                        return assessFormConstancySizeL1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VFC21':
                        return assessFormConstancyNumbersL2(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VFC22':
                        return assessFormConstancyLettersL2(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VFC23':
                        return assessFormConstancySizeL2(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Visual Spatial - Level Specific
                    case 'VSpac1':
                        return assessVisualSpatialLevel1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VSpac2':
                        return assessVisualSpatialLevel2(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'line':
                        return assessLineOrientation(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Visual Neglect - Critical Assessment
                    case 'VN1':
                        return assessVisualNeglectLevel1(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'VN2':
                        return assessVisualNeglectLevel2(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Figure Ground
                    case 'FG':
                        return assessFigureGroundTailored(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Sequential Memory Tasks - Context Specific
                    case 'beads':
                        return assessSequentialMemoryBeads(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'dressing':
                        return assessSequentialMemoryDressing(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'morning':
                        return assessMorningRoutine(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'lion':
                        return assessSequentialMemoryLion(score, timeSpent, accuracy, totalTaps, attempt);
                    case 'crow':
                        return assessSequentialMemoryCrow(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    // Motion Perception
                    case 'motion':
                        return assessMotionPerception(score, timeSpent, accuracy, totalTaps, attempt);
                    
                    default:
                        return assessGenericVisualProcessing(score, timeSpent, accuracy, totalTaps);
                }
            }
            
            // TAILORED INDIVIDUAL QUIZ ASSESSMENTS
            
            // Mirror Fixation - Most Critical CVI Indicator
            function assessMirrorFixationTailored(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Adjusted thresholds for normal population - only flag truly abnormal results
                if (score < 20) riskFactors += 4; // Severe fixation deficit
                else if (score < 35) riskFactors += 3; // Significant fixation issues
                else if (score < 50) riskFactors += 1; // Mild fixation concerns
                
                // Time-based assessment - more lenient for normal users
                if (timeSpent > 300) riskFactors += 3; // Very slow fixation
                else if (timeSpent > 200) riskFactors += 2; // Slow fixation
                else if (timeSpent > 150) riskFactors += 1; // Mildly slow
                
                // Accuracy patterns - adjusted for normal variation
                if (accuracy < 30) riskFactors += 3; // Poor fixation accuracy
                else if (accuracy < 45) riskFactors += 2; // Moderate accuracy issues
                else if (accuracy < 60) riskFactors += 1; // Mild accuracy concerns
                
                // Interaction patterns - more lenient
                if (totalTaps > 40) riskFactors += 2; // Excessive searching
                else if (totalTaps > 30) riskFactors += 1; // Some searching behavior
                
                // Determine risk level - higher thresholds
                if (riskFactors >= 8) riskLevel = 'high';
                else if (riskFactors >= 5) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Memory VM1 - Specific Assessment
            function assessVisualMemoryVM1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // VM1 adjusted thresholds for normal population
                if (score < 15) riskFactors += 4; // Severe memory deficit
                else if (score < 30) riskFactors += 3; // Significant memory issues
                else if (score < 45) riskFactors += 2; // Moderate memory concerns
                else if (score < 60) riskFactors += 1; // Mild memory inefficiency
                
                // Time thresholds - more lenient for memory tasks
                if (timeSpent > 400) riskFactors += 3; // Very slow memory processing
                else if (timeSpent > 300) riskFactors += 2; // Slow memory retrieval
                else if (timeSpent > 240) riskFactors += 1; // Mildly slow
                
                // Memory-specific accuracy patterns - adjusted
                if (accuracy < 25) riskFactors += 3; // Poor memory encoding
                else if (accuracy < 40) riskFactors += 2; // Moderate encoding issues
                else if (accuracy < 55) riskFactors += 1; // Mild encoding concerns
                
                // Memory uncertainty patterns - more lenient
                if (totalTaps > 50) riskFactors += 2; // High uncertainty
                else if (totalTaps > 35) riskFactors += 1; // Some uncertainty
                
                if (riskFactors >= 8) riskLevel = 'high';
                else if (riskFactors >= 5) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Sequential Memory - Tailored Assessment
            function assessVisualSequentialMemory(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Sequential memory adjusted for normal population
                if (score < 15) riskFactors += 4; // Severe sequential deficit
                else if (score < 30) riskFactors += 3; // Significant issues
                else if (score < 45) riskFactors += 2; // Moderate concerns
                else if (score < 60) riskFactors += 1; // Mild inefficiency
                
                // Sequential tasks - more realistic time expectations
                if (timeSpent > 500) riskFactors += 3; // Very slow sequential processing
                else if (timeSpent > 400) riskFactors += 2; // Slow processing
                else if (timeSpent > 300) riskFactors += 1; // Mildly slow
                
                // Sequential accuracy patterns - adjusted
                if (accuracy < 20) riskFactors += 3; // Poor sequential encoding
                else if (accuracy < 35) riskFactors += 2; // Moderate issues
                else if (accuracy < 50) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 8) riskLevel = 'high';
                else if (riskFactors >= 5) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Closure VC1 - Puzzle Specific
            function assessVisualClosurePuzzle(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // VC1 adjusted for normal population
                if (score < 20) riskFactors += 3; // Poor puzzle closure
                else if (score < 35) riskFactors += 2; // Moderate issues
                else if (score < 50) riskFactors += 1; // Mild concerns
                
                // Puzzle closure timing - more lenient
                if (timeSpent > 350) riskFactors += 2; // Slow puzzle completion
                else if (timeSpent > 250) riskFactors += 1; // Mildly slow
                
                // Puzzle accuracy - adjusted
                if (accuracy < 30) riskFactors += 2; // Poor puzzle recognition
                else if (accuracy < 45) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Closure VC2 - Matching Specific
            function assessVisualClosureMatching(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // VC2 adjusted for normal population
                if (score < 25) riskFactors += 3; // Poor matching closure
                else if (score < 40) riskFactors += 2; // Moderate issues
                else if (score < 55) riskFactors += 1; // Mild concerns
                
                // Matching timing - more lenient
                if (timeSpent > 300) riskFactors += 2; // Slow matching
                else if (timeSpent > 200) riskFactors += 1; // Mildly slow
                
                // Matching accuracy - adjusted
                if (accuracy < 35) riskFactors += 2; // Poor matching ability
                else if (accuracy < 50) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Closure VC3 - Animal Specific
            function assessVisualClosureAnimal(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // VC3 adjusted for normal population
                if (score < 20) riskFactors += 4; // Poor animal closure
                else if (score < 35) riskFactors += 3; // Moderate issues
                else if (score < 50) riskFactors += 2; // Mild concerns
                else if (score < 65) riskFactors += 1; // Very mild
                
                // Animal closure timing - more realistic
                if (timeSpent > 400) riskFactors += 3; // Very slow
                else if (timeSpent > 300) riskFactors += 2; // Slow
                else if (timeSpent > 220) riskFactors += 1; // Mildly slow
                
                // Animal recognition accuracy - adjusted
                if (accuracy < 30) riskFactors += 3; // Poor animal recognition
                else if (accuracy < 45) riskFactors += 2; // Moderate issues
                else if (accuracy < 60) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Closure VC4 - Most Complex
            function assessVisualClosureComplex(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // VC4 adjusted for normal population (most complex task)
                if (score < 15) riskFactors += 4; // Severe complex closure deficit
                else if (score < 30) riskFactors += 3; // Significant issues
                else if (score < 45) riskFactors += 2; // Moderate concerns
                else if (score < 60) riskFactors += 1; // Mild inefficiency
                
                // Complex closure timing - very lenient
                if (timeSpent > 500) riskFactors += 3; // Very slow complex processing
                else if (timeSpent > 400) riskFactors += 2; // Slow processing
                else if (timeSpent > 300) riskFactors += 1; // Mildly slow
                
                // Complex accuracy patterns - adjusted
                if (accuracy < 25) riskFactors += 3; // Poor complex integration
                else if (accuracy < 40) riskFactors += 2; // Moderate issues
                else if (accuracy < 55) riskFactors += 1; // Mild concerns
                
                // Complex task uncertainty - more lenient
                if (totalTaps > 50) riskFactors += 2; // High uncertainty
                else if (totalTaps > 35) riskFactors += 1; // Some uncertainty
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Discrimination - Shapes 1 Specific
            function assessVisualDiscriminationShapes1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Shape discrimination adjusted for normal population
                if (score < 25) riskFactors += 3; // Poor shape discrimination
                else if (score < 40) riskFactors += 2; // Moderate issues
                else if (score < 55) riskFactors += 1; // Mild concerns
                
                // Shape discrimination timing - more lenient
                if (timeSpent > 280) riskFactors += 2; // Slow shape processing
                else if (timeSpent > 200) riskFactors += 1; // Mildly slow
                
                // Shape accuracy - adjusted
                if (accuracy < 40) riskFactors += 2; // Poor shape recognition
                else if (accuracy < 55) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Discrimination - Shapes 2 Specific
            function assessVisualDiscriminationShapes2(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Complex shape discrimination adjusted for normal population
                if (score < 20) riskFactors += 3; // Poor complex shape discrimination
                else if (score < 35) riskFactors += 2; // Moderate issues
                else if (score < 50) riskFactors += 1; // Mild concerns
                
                // Complex shape timing - more lenient
                if (timeSpent > 320) riskFactors += 2; // Slow complex processing
                else if (timeSpent > 240) riskFactors += 1; // Mildly slow
                
                // Complex shape accuracy - adjusted
                if (accuracy < 35) riskFactors += 2; // Poor complex recognition
                else if (accuracy < 50) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Discrimination - Size Specific
            function assessVisualDiscriminationSize(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Size discrimination adjusted for normal population
                if (score < 30) riskFactors += 3; // Poor size discrimination
                else if (score < 45) riskFactors += 2; // Moderate issues
                else if (score < 60) riskFactors += 1; // Mild concerns
                
                // Size processing timing - more lenient
                if (timeSpent > 240) riskFactors += 2; // Slow size processing
                else if (timeSpent > 180) riskFactors += 1; // Mildly slow
                
                // Size accuracy - adjusted
                if (accuracy < 45) riskFactors += 2; // Poor size recognition
                else if (accuracy < 60) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Discrimination - Emotions Specific
            function assessVisualDiscriminationEmotions(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Emotion discrimination adjusted for normal population
                if (score < 15) riskFactors += 4; // Poor emotion discrimination
                else if (score < 30) riskFactors += 3; // Moderate issues
                else if (score < 45) riskFactors += 2; // Mild concerns
                else if (score < 60) riskFactors += 1; // Very mild
                
                // Emotion processing timing - more lenient
                if (timeSpent > 360) riskFactors += 3; // Very slow emotion processing
                else if (timeSpent > 280) riskFactors += 2; // Slow processing
                else if (timeSpent > 220) riskFactors += 1; // Mildly slow
                
                // Emotion accuracy - adjusted
                if (accuracy < 30) riskFactors += 3; // Poor emotion recognition
                else if (accuracy < 45) riskFactors += 2; // Moderate issues
                else if (accuracy < 60) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Discrimination - Colors Specific
            function assessVisualDiscriminationColors(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Color discrimination adjusted for normal population
                if (score < 35) riskFactors += 3; // Poor color discrimination
                else if (score < 50) riskFactors += 2; // Moderate issues
                else if (score < 65) riskFactors += 1; // Mild concerns
                
                // Color processing timing - more lenient
                if (timeSpent > 200) riskFactors += 2; // Slow color processing
                else if (timeSpent > 150) riskFactors += 1; // Mildly slow
                
                // Color accuracy - adjusted
                if (accuracy < 50) riskFactors += 2; // Poor color recognition
                else if (accuracy < 65) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Form Constancy - Numbers Level 1
            function assessFormConstancyNumbersL1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Number form constancy L1 adjusted for normal population
                if (score < 30) riskFactors += 3; // Poor number constancy
                else if (score < 45) riskFactors += 2; // Moderate issues
                else if (score < 60) riskFactors += 1; // Mild concerns
                
                // Number processing timing - more lenient
                if (timeSpent > 260) riskFactors += 2; // Slow number processing
                else if (timeSpent > 200) riskFactors += 1; // Mildly slow
                
                // Number accuracy - adjusted
                if (accuracy < 40) riskFactors += 2; // Poor number recognition
                else if (accuracy < 55) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Form Constancy - Letters Level 1
            function assessFormConstancyLettersL1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Letter form constancy L1 adjusted for normal population
                if (score < 25) riskFactors += 3; // Poor letter constancy
                else if (score < 40) riskFactors += 2; // Moderate issues
                else if (score < 55) riskFactors += 1; // Mild concerns
                
                // Letter processing timing - more lenient
                if (timeSpent > 280) riskFactors += 2; // Slow letter processing
                else if (timeSpent > 220) riskFactors += 1; // Mildly slow
                
                // Letter accuracy - adjusted
                if (accuracy < 35) riskFactors += 2; // Poor letter recognition
                else if (accuracy < 50) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Form Constancy - Size Level 1
            function assessFormConstancySizeL1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Size form constancy L1 adjusted for normal population
                if (score < 35) riskFactors += 3; // Poor size constancy
                else if (score < 50) riskFactors += 2; // Moderate issues
                else if (score < 65) riskFactors += 1; // Mild concerns
                
                // Size processing timing - more lenient
                if (timeSpent > 240) riskFactors += 2; // Slow size processing
                else if (timeSpent > 180) riskFactors += 1; // Mildly slow
                
                // Size accuracy - adjusted
                if (accuracy < 45) riskFactors += 2; // Poor size recognition
                else if (accuracy < 60) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Form Constancy - Numbers Level 2
            function assessFormConstancyNumbersL2(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Number form constancy L2 adjusted for normal population (more complex)
                if (score < 20) riskFactors += 4; // Poor complex number constancy
                else if (score < 35) riskFactors += 3; // Moderate issues
                else if (score < 50) riskFactors += 2; // Mild concerns
                else if (score < 65) riskFactors += 1; // Very mild
                
                // Complex number timing - more lenient
                if (timeSpent > 320) riskFactors += 3; // Very slow processing
                else if (timeSpent > 260) riskFactors += 2; // Slow processing
                else if (timeSpent > 200) riskFactors += 1; // Mildly slow
                
                // Complex number accuracy - adjusted
                if (accuracy < 30) riskFactors += 3; // Poor complex recognition
                else if (accuracy < 45) riskFactors += 2; // Moderate issues
                else if (accuracy < 60) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Form Constancy - Letters Level 2
            function assessFormConstancyLettersL2(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Letter form constancy L2 adjusted for normal population (more complex)
                if (score < 15) riskFactors += 4; // Poor complex letter constancy
                else if (score < 30) riskFactors += 3; // Moderate issues
                else if (score < 45) riskFactors += 2; // Mild concerns
                else if (score < 60) riskFactors += 1; // Very mild
                
                // Complex letter timing - more lenient
                if (timeSpent > 340) riskFactors += 3; // Very slow processing
                else if (timeSpent > 280) riskFactors += 2; // Slow processing
                else if (timeSpent > 220) riskFactors += 1; // Mildly slow
                
                // Complex letter accuracy - adjusted
                if (accuracy < 25) riskFactors += 3; // Poor complex recognition
                else if (accuracy < 40) riskFactors += 2; // Moderate issues
                else if (accuracy < 55) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Form Constancy - Size Level 2
            function assessFormConstancySizeL2(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Size form constancy L2 adjusted for normal population (more complex)
                if (score < 25) riskFactors += 4; // Poor complex size constancy
                else if (score < 40) riskFactors += 3; // Moderate issues
                else if (score < 55) riskFactors += 2; // Mild concerns
                else if (score < 70) riskFactors += 1; // Very mild
                
                // Complex size timing - more lenient
                if (timeSpent > 300) riskFactors += 3; // Very slow processing
                else if (timeSpent > 240) riskFactors += 2; // Slow processing
                else if (timeSpent > 180) riskFactors += 1; // Mildly slow
                
                // Complex size accuracy - adjusted
                if (accuracy < 35) riskFactors += 3; // Poor complex recognition
                else if (accuracy < 50) riskFactors += 2; // Moderate issues
                else if (accuracy < 65) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Memory Assessment
            function assessVisualMemory(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Visual memory adjusted for normal population
                if (score < 15 || accuracy < 25) {
                    riskLevel = 'high'; // Severe memory impairment
                } else if (score < 30 || accuracy < 40 || timeSpent > 360) {
                    riskLevel = 'medium'; // Moderate memory concerns
                } else if (score < 45 || timeSpent > 240 || totalTaps > 50) {
                    riskLevel = 'medium'; // Mild memory inefficiency
                }
                
                return riskLevel;
            }
            
            // Visual Closure Assessment
            function assessVisualClosure(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Adjust thresholds based on closure complexity
                const complexityFactor = quizType === 'VC4' ? 1.2 : quizType === 'VC3' ? 1.1 : 1.0;
                const timeThreshold = 150 * complexityFactor;
                
                if (score < 45 || accuracy < 55) {
                    riskLevel = 'high'; // Poor closure ability
                } else if (score < 65 || accuracy < 70 || timeSpent > timeThreshold) {
                    riskLevel = 'medium'; // Moderate closure difficulties
                } else if (score < 80 || timeSpent > (timeThreshold * 0.8) || totalTaps > 20) {
                    riskLevel = 'medium'; // Mild closure concerns
                }
                
                return riskLevel;
            }
            
            // Visual Discrimination Assessment
            function assessVisualDiscrimination(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Different discrimination types have different implications
                const isColorDiscrimination = quizType.includes('C');
                const isShapeDiscrimination = quizType.includes('S');
                const isExpressionDiscrimination = quizType.includes('E');
                
                if (score < 50 || accuracy < 60) {
                    riskLevel = 'high'; // Poor discrimination is concerning
                } else if (score < 70 || accuracy < 75 || timeSpent > 120) {
                    riskLevel = 'medium'; // Moderate discrimination issues
                } else if (score < 85 || timeSpent > 90 || totalTaps > 18) {
                    riskLevel = 'medium'; // Mild discrimination inefficiency
                }
                
                // Color discrimination issues may indicate different pathways
                if (isColorDiscrimination && score < 60) {
                    riskLevel = riskLevel === 'low' ? 'medium' : 'high';
                }
                
                return riskLevel;
            }
            
            // Visual Form Constancy Assessment
            function assessVisualFormConstancy(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Form constancy is crucial for object recognition
                if (score < 45 || accuracy < 55) {
                    riskLevel = 'high'; // Poor form constancy
                } else if (score < 65 || accuracy < 70 || timeSpent > 140) {
                    riskLevel = 'medium'; // Moderate form constancy issues
                } else if (score < 80 || timeSpent > 100 || totalTaps > 22) {
                    riskLevel = 'medium'; // Mild form constancy concerns
                }
                
                return riskLevel;
            }
            
            // Visual Spatial Assessment
            function assessVisualSpatial(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Spatial processing deficits are significant in CVI
                if (score < 40 || accuracy < 50) {
                    riskLevel = 'high'; // Severe spatial deficits
                } else if (score < 60 || accuracy < 65 || timeSpent > 155) {
                    riskLevel = 'medium'; // Moderate spatial issues
                } else if (score < 75 || timeSpent > 120 || totalTaps > 25) {
                    riskLevel = 'medium'; // Mild spatial concerns
                }
                
                return riskLevel;
            }
            
            // Visual Neglect Assessment - Critical for CVI
            function assessVisualNeglect(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Visual neglect is a serious indicator of CVI
                if (score < 60 || accuracy < 65) {
                    riskLevel = 'high'; // Significant neglect patterns
                } else if (score < 75 || accuracy < 80 || timeSpent > 110) {
                    riskLevel = 'medium'; // Mild neglect tendencies
                } else if (timeSpent > 80 || totalTaps > 15) {
                    riskLevel = 'medium'; // Inefficient visual scanning
                }
                
                return riskLevel;
            }
            
            // Figure-Ground Assessment
            function assessFigureGround(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Figure-ground separation is often impaired in CVI
                if (score < 45 || accuracy < 55) {
                    riskLevel = 'high'; // Poor figure-ground separation
                } else if (score < 65 || accuracy < 70 || timeSpent > 130) {
                    riskLevel = 'medium'; // Moderate figure-ground issues
                } else if (score < 80 || timeSpent > 100 || totalTaps > 20) {
                    riskLevel = 'medium'; // Mild figure-ground concerns
                }
                
                return riskLevel;
            }
            
            // Functional Vision Assessment
            function assessFunctionalVision(score, timeSpent, accuracy, totalTaps, quizType) {
                let riskLevel = 'low';
                
                // Functional vision tasks reflect real-world visual processing
                if (score < 50 || accuracy < 60) {
                    riskLevel = 'high'; // Poor functional vision
                } else if (score < 70 || accuracy < 75 || timeSpent > 200) {
                    riskLevel = 'medium'; // Moderate functional concerns
                } else if (score < 85 || timeSpent > 150 || totalTaps > 30) {
                    riskLevel = 'medium'; // Mild functional inefficiency
                }
                
                return riskLevel;
            }
            
            // Visual Spatial Level 1
            function assessVisualSpatialLevel1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Spatial L1 adjusted for normal population
                if (score < 25) riskFactors += 3; // Poor spatial processing
                else if (score < 40) riskFactors += 2; // Moderate issues
                else if (score < 55) riskFactors += 1; // Mild concerns
                
                // Spatial timing - more lenient
                if (timeSpent > 300) riskFactors += 2; // Slow spatial processing
                else if (timeSpent > 240) riskFactors += 1; // Mildly slow
                
                // Spatial accuracy - adjusted
                if (accuracy < 35) riskFactors += 2; // Poor spatial accuracy
                else if (accuracy < 50) riskFactors += 1; // Moderate issues
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Spatial Level 2
            function assessVisualSpatialLevel2(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Spatial L2 adjusted for normal population (more complex)
                if (score < 15) riskFactors += 4; // Poor complex spatial processing
                else if (score < 30) riskFactors += 3; // Moderate issues
                else if (score < 45) riskFactors += 2; // Mild concerns
                else if (score < 60) riskFactors += 1; // Very mild
                
                // Complex spatial timing - more lenient
                if (timeSpent > 360) riskFactors += 3; // Very slow processing
                else if (timeSpent > 300) riskFactors += 2; // Slow processing
                else if (timeSpent > 240) riskFactors += 1; // Mildly slow
                
                // Complex spatial accuracy - adjusted
                if (accuracy < 25) riskFactors += 3; // Poor complex spatial accuracy
                else if (accuracy < 40) riskFactors += 2; // Moderate issues
                else if (accuracy < 55) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Line Orientation
            function assessLineOrientation(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Line orientation adjusted for normal population
                if (score < 20) riskFactors += 4; // Poor line orientation
                else if (score < 35) riskFactors += 3; // Moderate issues
                else if (score < 50) riskFactors += 2; // Mild concerns
                else if (score < 65) riskFactors += 1; // Very mild
                
                // Line orientation timing - more lenient
                if (timeSpent > 280) riskFactors += 3; // Very slow processing
                else if (timeSpent > 220) riskFactors += 2; // Slow processing
                else if (timeSpent > 160) riskFactors += 1; // Mildly slow
                
                // Line accuracy - adjusted
                if (accuracy < 30) riskFactors += 3; // Poor line recognition
                else if (accuracy < 45) riskFactors += 2; // Moderate issues
                else if (accuracy < 60) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Neglect Level 1 - Critical
            function assessVisualNeglectLevel1(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Neglect adjusted for normal population
                if (score < 25) riskFactors += 4; // Significant neglect patterns
                else if (score < 40) riskFactors += 3; // Moderate neglect
                else if (score < 55) riskFactors += 2; // Mild neglect tendencies
                else if (score < 70) riskFactors += 1; // Very mild
                
                // Neglect timing patterns - more lenient
                if (timeSpent > 240) riskFactors += 3; // Very slow scanning
                else if (timeSpent > 180) riskFactors += 2; // Slow scanning
                else if (timeSpent > 140) riskFactors += 1; // Mildly slow
                
                // Neglect accuracy patterns - adjusted
                if (accuracy < 35) riskFactors += 4; // Poor visual field coverage
                else if (accuracy < 50) riskFactors += 3; // Moderate field issues
                else if (accuracy < 65) riskFactors += 2; // Mild field concerns
                else if (accuracy < 80) riskFactors += 1; // Very mild
                
                if (riskFactors >= 10) riskLevel = 'high';
                else if (riskFactors >= 7) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Visual Neglect Level 2 - Critical
            function assessVisualNeglectLevel2(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Complex neglect adjusted for normal population
                if (score < 20) riskFactors += 5; // Severe neglect patterns
                else if (score < 35) riskFactors += 4; // Significant neglect
                else if (score < 50) riskFactors += 3; // Moderate neglect
                else if (score < 65) riskFactors += 2; // Mild neglect
                else if (score < 80) riskFactors += 1; // Very mild
                
                // Complex neglect timing - more lenient
                if (timeSpent > 300) riskFactors += 4; // Very slow complex scanning
                else if (timeSpent > 240) riskFactors += 3; // Slow scanning
                else if (timeSpent > 180) riskFactors += 2; // Moderate scanning
                else if (timeSpent > 140) riskFactors += 1; // Mildly slow
                
                // Complex neglect accuracy - adjusted
                if (accuracy < 30) riskFactors += 4; // Poor complex field coverage
                else if (accuracy < 45) riskFactors += 3; // Moderate issues
                else if (accuracy < 60) riskFactors += 2; // Mild concerns
                else if (accuracy < 75) riskFactors += 1; // Very mild
                
                if (riskFactors >= 11) riskLevel = 'high';
                else if (riskFactors >= 8) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Figure Ground Tailored
            function assessFigureGroundTailored(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Figure-ground separation adjusted for normal population
                if (score < 20) riskFactors += 4; // Poor figure-ground separation
                else if (score < 35) riskFactors += 3; // Moderate issues
                else if (score < 50) riskFactors += 2; // Mild concerns
                else if (score < 65) riskFactors += 1; // Very mild
                
                // Figure-ground timing - more lenient
                if (timeSpent > 320) riskFactors += 3; // Very slow separation
                else if (timeSpent > 260) riskFactors += 2; // Slow separation
                else if (timeSpent > 200) riskFactors += 1; // Mildly slow
                
                // Figure-ground accuracy - adjusted
                if (accuracy < 30) riskFactors += 3; // Poor separation ability
                else if (accuracy < 45) riskFactors += 2; // Moderate issues
                else if (accuracy < 60) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Sequential Memory - Beads
            function assessSequentialMemoryBeads(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Beads sequence adjusted for normal population
                if (score < 10) riskFactors += 4; // Poor bead sequencing
                else if (score < 25) riskFactors += 3; // Moderate issues
                else if (score < 40) riskFactors += 2; // Mild concerns
                else if (score < 55) riskFactors += 1; // Very mild
                
                // Beads timing - more lenient
                if (timeSpent > 560) riskFactors += 3; // Very slow sequencing
                else if (timeSpent > 440) riskFactors += 2; // Slow sequencing
                else if (timeSpent > 360) riskFactors += 1; // Mildly slow
                
                // Beads accuracy - adjusted
                if (accuracy < 20) riskFactors += 3; // Poor sequence accuracy
                else if (accuracy < 35) riskFactors += 2; // Moderate issues
                else if (accuracy < 50) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Sequential Memory - Dressing
            function assessSequentialMemoryDressing(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Dressing sequence adjusted for normal population
                if (score < 15) riskFactors += 4; // Poor dressing sequencing
                else if (score < 30) riskFactors += 3; // Moderate issues
                else if (score < 45) riskFactors += 2; // Mild concerns
                else if (score < 60) riskFactors += 1; // Very mild
                
                // Dressing timing - more lenient
                if (timeSpent > 520) riskFactors += 3; // Very slow sequencing
                else if (timeSpent > 400) riskFactors += 2; // Slow sequencing
                else if (timeSpent > 320) riskFactors += 1; // Mildly slow
                
                // Dressing accuracy - adjusted
                if (accuracy < 25) riskFactors += 3; // Poor sequence accuracy
                else if (accuracy < 40) riskFactors += 2; // Moderate issues
                else if (accuracy < 55) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Morning Routine Assessment
            function assessMorningRoutine(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Morning routine adjusted for normal population
                if (score < 20) riskFactors += 4; // Poor routine sequencing
                else if (score < 35) riskFactors += 3; // Moderate issues
                else if (score < 50) riskFactors += 2; // Mild concerns
                else if (score < 65) riskFactors += 1; // Very mild
                
                // Routine timing - more lenient
                if (timeSpent > 480) riskFactors += 3; // Very slow routine processing
                else if (timeSpent > 360) riskFactors += 2; // Slow processing
                else if (timeSpent > 280) riskFactors += 1; // Mildly slow
                
                // Routine accuracy - adjusted
                if (accuracy < 30) riskFactors += 3; // Poor routine understanding
                else if (accuracy < 45) riskFactors += 2; // Moderate issues
                else if (accuracy < 60) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Sequential Memory - Lion
            function assessSequentialMemoryLion(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Lion sequence adjusted for normal population
                if (score < 5) riskFactors += 4; // Poor lion sequencing
                else if (score < 20) riskFactors += 3; // Moderate issues
                else if (score < 35) riskFactors += 2; // Mild concerns
                else if (score < 50) riskFactors += 1; // Very mild
                
                // Lion timing - more lenient
                if (timeSpent > 600) riskFactors += 3; // Very slow sequencing
                else if (timeSpent > 480) riskFactors += 2; // Slow sequencing
                else if (timeSpent > 380) riskFactors += 1; // Mildly slow
                
                // Lion accuracy - adjusted
                if (accuracy < 15) riskFactors += 3; // Poor sequence accuracy
                else if (accuracy < 30) riskFactors += 2; // Moderate issues
                else if (accuracy < 45) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 9) riskLevel = 'high';
                else if (riskFactors >= 6) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Sequential Memory - Crow
            function assessSequentialMemoryCrow(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Crow sequence adjusted for normal population
                if (score < 10) riskFactors += 4; // Poor crow sequencing
                else if (score < 25) riskFactors += 3; // Moderate issues
                else if (score < 40) riskFactors += 2; // Mild concerns
                else if (score < 55) riskFactors += 1; // Very mild
                
                // Crow timing - more lenient
                if (timeSpent > 540) riskFactors += 3; // Very slow sequencing
                else if (timeSpent > 420) riskFactors += 2; // Slow sequencing
                else if (timeSpent > 340) riskFactors += 1; // Mildly slow
                
                // Crow accuracy
                if (accuracy < 40) riskFactors += 3; // Poor sequence accuracy
                else if (accuracy < 60) riskFactors += 2; // Moderate issues
                else if (accuracy < 75) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 7) riskLevel = 'high';
                else if (riskFactors >= 4) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Motion Perception
            function assessMotionPerception(score, timeSpent, accuracy, totalTaps, attempt) {
                let riskLevel = 'low';
                let riskFactors = 0;
                
                // Motion perception thresholds
                if (score < 40) riskFactors += 4; // Poor motion perception
                else if (score < 60) riskFactors += 3; // Moderate issues
                else if (score < 75) riskFactors += 2; // Mild concerns
                else if (score < 85) riskFactors += 1; // Very mild
                
                // Motion timing
                if (timeSpent > 120) riskFactors += 2; // Slow motion processing
                else if (timeSpent > 90) riskFactors += 1; // Mildly slow
                
                // Motion accuracy
                if (accuracy < 50) riskFactors += 3; // Poor motion detection
                else if (accuracy < 70) riskFactors += 2; // Moderate issues
                else if (accuracy < 85) riskFactors += 1; // Mild concerns
                
                if (riskFactors >= 6) riskLevel = 'high';
                else if (riskFactors >= 3) riskLevel = 'medium';
                
                return riskLevel;
            }
            
            // Generic Visual Processing Assessment
            function assessGenericVisualProcessing(score, timeSpent, accuracy, totalTaps) {
                let riskLevel = 'low';
                
                if (score < 45 || accuracy < 55) {
                    riskLevel = 'high';
                } else if (score < 65 || accuracy < 70 || timeSpent > 120) {
                    riskLevel = 'medium';
                } else if (score < 80 || timeSpent > 90 || totalTaps > 20) {
                    riskLevel = 'medium';
                }
                
                return riskLevel;
            }
            
            function calculateOverallCVIRisk(quizRisks) {
                if (Object.keys(quizRisks).length === 0) return 'medium';
                
                const riskCounts = { high: 0, medium: 0, low: 0 };
                
                // Define critical assessment categories with clinical weights
                const criticalAssessments = {
                    'mirror': { weight: 3, category: 'fixation' },           // Most critical
                    'VN': { weight: 3, category: 'neglect' },                // Visual neglect
                    'VN1': { weight: 3, category: 'neglect' },
                    'VN2': { weight: 3, category: 'neglect' },
                    'VM1': { weight: 2, category: 'memory' },                // Visual memory
                    'VSM': { weight: 2, category: 'memory' },
                    'VC4': { weight: 2, category: 'closure' },               // Complex closure
                    'VFC1': { weight: 2, category: 'form_constancy' },       // Form constancy
                    'VFC2': { weight: 2, category: 'form_constancy' },
                    'VSpac2': { weight: 2, category: 'spatial' },            // Complex spatial
                    'VFigure1': { weight: 2, category: 'figure_ground' },    // Figure-ground
                    'VFigure2': { weight: 2, category: 'figure_ground' }
                };
                
                let criticalRiskScore = 0;
                let totalCriticalWeight = 0;
                const categoryRisks = {};
                
                // Analyze each quiz result
                Object.entries(quizRisks).forEach(([quizType, risk]) => {
                    riskCounts[risk]++;
                    
                    // Check if this is a critical assessment
                    if (criticalAssessments[quizType]) {
                        const assessment = criticalAssessments[quizType];
                        const riskValue = risk === 'high' ? 3 : risk === 'medium' ? 2 : 1;
                        
                        criticalRiskScore += riskValue * assessment.weight;
                        totalCriticalWeight += assessment.weight * 3; // Max possible score
                        
                        // Track category-specific risks
                        if (!categoryRisks[assessment.category]) {
                            categoryRisks[assessment.category] = [];
                        }
                        categoryRisks[assessment.category].push(risk);
                    }
                });
                
                const totalQuizzes = Object.keys(quizRisks).length;
                const highRiskPercentage = (riskCounts.high / totalQuizzes) * 100;
                const mediumRiskPercentage = (riskCounts.medium / totalQuizzes) * 100;
                const criticalRiskPercentage = totalCriticalWeight > 0 ? (criticalRiskScore / totalCriticalWeight) * 100 : 0;
                
                // Analyze category-specific patterns
                const categoryAnalysis = analyzeCategoryRisks(categoryRisks);
                
                // Determine overall risk level with enhanced clinical logic
                
                // HIGH RISK CONDITIONS:
                // 1. Mirror fixation shows high risk (fundamental CVI indicator)
                if (quizRisks['mirror'] === 'high') {
                    return 'high';
                }
                
                // 2. Multiple critical assessments show high risk
                const criticalHighCount = Object.keys(criticalAssessments)
                    .filter(quiz => quizRisks[quiz] === 'high').length;
                if (criticalHighCount >= 2) {
                    return 'high';
                }
                
                // 3. Visual neglect with any other high-risk assessment
                if ((quizRisks['VN'] === 'high' || quizRisks['VN1'] === 'high' || quizRisks['VN2'] === 'high') &&
                    riskCounts.high > 1) {
                    return 'high';
                }
                
                // 4. High percentage of overall high-risk results
                if (highRiskPercentage > 35 || criticalRiskPercentage > 70) {
                    return 'high';
                }
                
                // 5. Specific category combinations indicating CVI
                if (categoryAnalysis.hasMultipleCriticalCategories) {
                    return 'high';
                }
                
                // MEDIUM RISK CONDITIONS:
                // 1. Any critical assessment shows high risk
                if (criticalHighCount >= 1) {
                    return 'medium';
                }
                
                // 2. Mirror fixation shows medium risk
                if (quizRisks['mirror'] === 'medium') {
                    return 'medium';
                }
                
                // 3. Multiple medium-risk critical assessments
                const criticalMediumCount = Object.keys(criticalAssessments)
                    .filter(quiz => quizRisks[quiz] === 'medium').length;
                if (criticalMediumCount >= 3) {
                    return 'medium';
                }
                
                // 4. Moderate percentage thresholds
                if (highRiskPercentage > 15 || 
                    (highRiskPercentage + mediumRiskPercentage) > 50 ||
                    criticalRiskPercentage > 50) {
                    return 'medium';
                }
                
                // 5. Category-specific medium risk patterns
                if (categoryAnalysis.hasConcerningPatterns) {
                    return 'medium';
                }
                
                return 'low';
            }
            
            // Analyze category-specific risk patterns
            function analyzeCategoryRisks(categoryRisks) {
                let hasMultipleCriticalCategories = false;
                let hasConcerningPatterns = false;
                let criticalCategoriesWithHighRisk = 0;
                
                Object.entries(categoryRisks).forEach(([category, risks]) => {
                    const hasHighRisk = risks.includes('high');
                    const hasMediumRisk = risks.includes('medium');
                    const mediumOrHighCount = risks.filter(r => r === 'medium' || r === 'high').length;
                    
                    if (hasHighRisk) {
                        criticalCategoriesWithHighRisk++;
                    }
                    
                    // Concerning patterns within categories
                    if (mediumOrHighCount >= 2) {
                        hasConcerningPatterns = true;
                    }
                });
                
                // Multiple critical categories with high risk
                if (criticalCategoriesWithHighRisk >= 2) {
                    hasMultipleCriticalCategories = true;
                }
                
                return {
                    hasMultipleCriticalCategories,
                    hasConcerningPatterns,
                    criticalCategoriesWithHighRisk
                };
            }
            
            function generateCVIRiskReport(latestAttempts) {
                const quizRisks = {};
                
                // Calculate individual quiz risks
                Object.entries(latestAttempts).forEach(([quizType, attempt]) => {
                    quizRisks[quizType] = calculateCVIRisk(quizType, attempt);
                });
                
                // Calculate overall risk
                const overallRisk = calculateOverallCVIRisk(quizRisks);
                
                // Generate simple risk report HTML
                let reportHTML = `
                    <div class="cvi-risk-section">
                        <h2>🔍 CVI Risk Assessment</h2>
                        
                        <div class="overall-risk-container">
                            <div class="overall-risk-indicator cvi-risk-${overallRisk}">
                                <span class="risk-label">Overall CVI Risk:</span>
                                <span class="risk-value">${overallRisk.toUpperCase()}</span>
                            </div>
                        </div>
                        
                        <div class="individual-quiz-risks">
                            <h3>Individual Quiz Risk Assessment</h3>
                            <div class="quiz-risk-grid">
                `;
                
                // Add individual quiz risk badges
                Object.entries(quizRisks).forEach(([quizType, risk]) => {
                    const displayName = quizNames[quizType] || quizType;
                    const attempt = latestAttempts[quizType];
                    const score = Math.round(attempt.score || 0);
                    
                    reportHTML += `
                        <div class="quiz-risk-item">
                            <div class="quiz-name">${displayName}</div>
                            <div class="quiz-score">Score: ${score}%</div>
                            <div class="quiz-risk-badge cvi-risk-${risk}">${risk.toUpperCase()}</div>
                        </div>
                    `;
                });
                
                reportHTML += `
                            </div>
                        </div>
                    </div>
                `;
                
                return reportHTML;
            }
            

            
            // COMPREHENSIVE DATA ANALYSIS FOR CVI THRESHOLD CALIBRATION
            async function analyzeQuizDataForThresholds() {
                console.log('🔍 Starting comprehensive quiz data analysis for CVI threshold calibration...');
                
                const allQuizData = {};
                const performanceStats = {};
                
                try {
                    // Get all users data
                    const usersSnapshot = await database.ref('users').once('value');
                    const usersData = usersSnapshot.val() || {};
                    
                    // Get all doctors and their patients data
                    const doctorsSnapshot = await database.ref('doctors').once('value');
                    const doctorsData = doctorsSnapshot.val() || {};
                    
                    console.log(`📊 Found ${Object.keys(usersData).length} users and ${Object.keys(doctorsData).length} doctors`);
                    
                    // Process users data
                    Object.entries(usersData).forEach(([userId, userData]) => {
                        if (userData.quiz) {
                            processUserQuizData(userData.quiz, userId, 'user');
                        }
                        if (userData.quizzes) {
                            processUserQuizData(userData.quizzes, userId, 'user');
                        }
                    });
                    
                    // Process doctors' patients data
                    Object.entries(doctorsData).forEach(([doctorId, doctorData]) => {
                        if (doctorData.patients) {
                            Object.entries(doctorData.patients).forEach(([patientId, patientData]) => {
                                if (patientData.quiz) {
                                    processUserQuizData(patientData.quiz, patientId, 'patient');
                                }
                                if (patientData.quizzes) {
                                    processUserQuizData(patientData.quizzes, patientId, 'patient');
                                }
                            });
                        }
                    });
                    
                    function processUserQuizData(quizData, userId, userType) {
                        Object.entries(quizData).forEach(([quizType, quizTypeData]) => {
                            if (!allQuizData[quizType]) {
                                allQuizData[quizType] = [];
                            }
                            
                            // Extract all attempts for this quiz type
                            const attempts = extractAllAttempts(quizTypeData, quizType);
                            attempts.forEach(attempt => {
                                allQuizData[quizType].push({
                                    ...attempt,
                                    userId,
                                    userType,
                                    quizType
                                });
                            });
                        });
                    }
                    
                    function extractAllAttempts(quizTypeData, quizType) {
                        const attempts = [];
                        
                        if (quizTypeData.attempts) {
                            // Standard attempts structure
                            Object.values(quizTypeData.attempts).forEach(attempt => {
                                if (attempt && typeof attempt === 'object') {
                                    attempts.push(attempt);
                                }
                            });
                        } else if (typeof quizTypeData === 'object') {
                            // Direct timestamp structure or mirror sub-branches
                            const processData = (data, prefix = '') => {
                                Object.entries(data).forEach(([key, value]) => {
                                    if (!isNaN(parseInt(key)) && value && typeof value === 'object') {
                                        // Timestamp entry
                                        attempts.push({
                                            ...value,
                                            timestamp: parseInt(key)
                                        });
                                    } else if (isNaN(parseInt(key)) && value && typeof value === 'object') {
                                        // Sub-branch (like mirror assessment)
                                        processData(value, key);
                                    }
                                });
                            };
                            processData(quizTypeData);
                        }
                        
                        return attempts;
                    }
                    
                    // Analyze performance statistics for each quiz type
                    Object.entries(allQuizData).forEach(([quizType, attempts]) => {
                        if (attempts.length === 0) return;
                        
                        const scores = attempts.map(a => a.score || 0).filter(s => s >= 0);
                        const times = attempts.map(a => (a.timeSpent || 0) / 1000).filter(t => t > 0);
                        const accuracies = attempts.map(a => a.accuracy || 0).filter(a => a >= 0);
                        const taps = attempts.map(a => a.totalTaps || a.totalClicks || 0).filter(t => t >= 0);
                        
                        if (scores.length === 0) return;
                        
                        performanceStats[quizType] = {
                            totalAttempts: attempts.length,
                            scores: {
                                min: Math.min(...scores),
                                max: Math.max(...scores),
                                mean: scores.reduce((a, b) => a + b, 0) / scores.length,
                                median: getMedian(scores),
                                p10: getPercentile(scores, 10),
                                p25: getPercentile(scores, 25),
                                p75: getPercentile(scores, 75),
                                p90: getPercentile(scores, 90),
                                std: getStandardDeviation(scores)
                            },
                            times: times.length > 0 ? {
                                min: Math.min(...times),
                                max: Math.max(...times),
                                mean: times.reduce((a, b) => a + b, 0) / times.length,
                                median: getMedian(times),
                                p75: getPercentile(times, 75),
                                p90: getPercentile(times, 90)
                            } : null,
                            accuracies: accuracies.length > 0 ? {
                                min: Math.min(...accuracies),
                                max: Math.max(...accuracies),
                                mean: accuracies.reduce((a, b) => a + b, 0) / accuracies.length,
                                median: getMedian(accuracies),
                                p10: getPercentile(accuracies, 10),
                                p25: getPercentile(accuracies, 25)
                            } : null,
                            taps: taps.length > 0 ? {
                                min: Math.min(...taps),
                                max: Math.max(...taps),
                                mean: taps.reduce((a, b) => a + b, 0) / taps.length,
                                median: getMedian(taps),
                                p75: getPercentile(taps, 75),
                                p90: getPercentile(taps, 90)
                            } : null
                        };
                    });
                    
                    // Helper functions for statistical analysis
                    function getMedian(arr) {
                        const sorted = [...arr].sort((a, b) => a - b);
                        const mid = Math.floor(sorted.length / 2);
                        return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                    }
                    
                    function getPercentile(arr, percentile) {
                        const sorted = [...arr].sort((a, b) => a - b);
                        const index = (percentile / 100) * (sorted.length - 1);
                        const lower = Math.floor(index);
                        const upper = Math.ceil(index);
                        const weight = index % 1;
                        return sorted[lower] * (1 - weight) + sorted[upper] * weight;
                    }
                    
                    function getStandardDeviation(arr) {
                        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                        const variance = arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
                        return Math.sqrt(variance);
                    }
                    
                    // Generate calibrated thresholds based on actual data
                    const calibratedThresholds = generateCalibratedThresholds(performanceStats);
                    
                    // Display comprehensive analysis results
                    displayAnalysisResults(performanceStats, calibratedThresholds, allQuizData);
                    
                } catch (error) {
                    console.error('Error during data analysis:', error);
                }
            }
            
            function generateCalibratedThresholds(performanceStats) {
                const thresholds = {};
                
                // Quiz-specific assessment parameters based on existing CVI logic
                const quizSpecificParams = {
                    'mirror': {
                        scoreThresholds: [20, 35, 50], // high, medium, mild risk
                        timeThresholds: [150, 200, 300], // mild, moderate, severe
                        accuracyThresholds: [30, 45, 60],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [5, 8] // medium, high
                    },
                    'VM1': {
                        scoreThresholds: [15, 30, 45, 60],
                        timeThresholds: [240, 300, 400],
                        accuracyThresholds: [25, 40, 55],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [5, 8]
                    },
                    'VSM': {
                        scoreThresholds: [15, 30, 45, 60],
                        timeThresholds: [300, 400, 500],
                        accuracyThresholds: [20, 35, 50],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [5, 8]
                    },
                    'VC1': {
                        scoreThresholds: [20, 35, 50],
                        timeThresholds: [250, 350],
                        accuracyThresholds: [30, 45],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [4, 6]
                    },
                    'VC2': {
                        scoreThresholds: [25, 40, 55],
                        timeThresholds: [200, 300],
                        accuracyThresholds: [35, 50],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [4, 6]
                    },
                    'VC3': {
                        scoreThresholds: [20, 35, 50, 65],
                        timeThresholds: [220, 300, 400],
                        accuracyThresholds: [30, 45, 60],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [6, 9]
                    },
                    'VC4': {
                        scoreThresholds: [15, 30, 45, 60],
                        timeThresholds: [300, 400, 500],
                        accuracyThresholds: [25, 40, 55],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [6, 9]
                    },
                    'VDTS1': {
                        scoreThresholds: [25, 40, 55],
                        timeThresholds: [200, 280],
                        accuracyThresholds: [40, 55],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [4, 6]
                    },
                    'VDTS2': {
                        scoreThresholds: [20, 35, 50],
                        timeThresholds: [240, 320],
                        accuracyThresholds: [35, 50],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [4, 6]
                    },
                    'VDTE': {
                        scoreThresholds: [15, 30, 45, 60],
                        timeThresholds: [220, 280, 360],
                        accuracyThresholds: [30, 45, 60],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [6, 9]
                    },
                    'VDTC': {
                        scoreThresholds: [35, 50, 65],
                        timeThresholds: [150, 200],
                        accuracyThresholds: [50, 65],
                        tapThresholds: [25, 35],
                        riskFactorThresholds: [4, 6]
                    },
                    'VFC11': {
                        scoreThresholds: [30, 45, 60],
                        timeThresholds: [200, 260],
                        accuracyThresholds: [40, 55],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [4, 6]
                    },
                    'VN1': {
                        scoreThresholds: [25, 40, 55],
                        timeThresholds: [180, 240, 320],
                        accuracyThresholds: [35, 50, 65],
                        tapThresholds: [30, 45],
                        riskFactorThresholds: [5, 8]
                    },
                    'VN2': {
                        scoreThresholds: [20, 35, 50],
                        timeThresholds: [200, 280, 380],
                        accuracyThresholds: [30, 45, 60],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [5, 8]
                    },
                    'VSpac1': {
                        scoreThresholds: [25, 40, 55],
                        timeThresholds: [220, 300, 400],
                        accuracyThresholds: [35, 50, 65],
                        tapThresholds: [30, 45],
                        riskFactorThresholds: [5, 8]
                    },
                    'VSpac2': {
                        scoreThresholds: [20, 35, 50],
                        timeThresholds: [250, 350, 450],
                        accuracyThresholds: [30, 45, 60],
                        tapThresholds: [35, 50],
                        riskFactorThresholds: [5, 8]
                    }
                };
                
                Object.entries(performanceStats).forEach(([quizType, stats]) => {
                    const scores = stats.scores;
                    const times = stats.times;
                    const accuracies = stats.accuracies;
                    const taps = stats.taps;
                    
                    // Get quiz-specific parameters or use defaults
                    const params = quizSpecificParams[quizType] || {
                        scoreThresholds: [20, 35, 50],
                        timeThresholds: [200, 300, 400],
                        accuracyThresholds: [30, 45, 60],
                        tapThresholds: [30, 40],
                        riskFactorThresholds: [5, 8]
                    };
                    
                    // Analyze actual data against existing thresholds
                    const scoreAnalysis = analyzeParameterFit(scores, params.scoreThresholds, 'score');
                    const timeAnalysis = times ? analyzeParameterFit(times, params.timeThresholds, 'time') : null;
                    const accuracyAnalysis = accuracies ? analyzeParameterFit(accuracies, params.accuracyThresholds, 'accuracy') : null;
                    const tapAnalysis = taps ? analyzeParameterFit(taps, params.tapThresholds, 'taps') : null;
                    
                    // Generate calibrated thresholds based on data fit
                    thresholds[quizType] = {
                        originalParams: params,
                        score: {
                            current: scoreAnalysis.current,
                            recommended: scoreAnalysis.recommended,
                            fit: scoreAnalysis.fit,
                            adjustment: scoreAnalysis.adjustment
                        },
                        time: timeAnalysis ? {
                            current: timeAnalysis.current,
                            recommended: timeAnalysis.recommended,
                            fit: timeAnalysis.fit,
                            adjustment: timeAnalysis.adjustment
                        } : null,
                        accuracy: accuracyAnalysis ? {
                            current: accuracyAnalysis.current,
                            recommended: accuracyAnalysis.recommended,
                            fit: accuracyAnalysis.fit,
                            adjustment: accuracyAnalysis.adjustment
                        } : null,
                        taps: tapAnalysis ? {
                            current: tapAnalysis.current,
                            recommended: tapAnalysis.recommended,
                            fit: tapAnalysis.fit,
                            adjustment: tapAnalysis.adjustment
                        } : null,
                        dataStats: {
                            totalAttempts: stats.totalAttempts,
                            scoreMean: scores.mean,
                            scoreMedian: scores.median,
                            timeMean: times ? times.mean : null,
                            accuracyMean: accuracies ? accuracies.mean : null
                        }
                    };
                });
                
                return thresholds;
            }
            
            // Analyze how well actual data fits existing thresholds
            function analyzeParameterFit(dataArray, thresholds, paramType) {
                const sorted = [...dataArray].sort((a, b) => a - b);
                const mean = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
                const median = getMedian(dataArray);
                const p10 = getPercentile(dataArray, 10);
                const p25 = getPercentile(dataArray, 25);
                const p75 = getPercentile(dataArray, 75);
                const p90 = getPercentile(dataArray, 90);
                
                let fit = 'good';
                let adjustment = 'none';
                let recommended = [...thresholds];
                
                if (paramType === 'score' || paramType === 'accuracy') {
                    // For scores and accuracy, lower values are worse
                    const highRiskThreshold = thresholds[0];
                    const mediumRiskThreshold = thresholds[1];
                    
                    // Check if too many normal users are being flagged
                    const belowHighRisk = dataArray.filter(v => v < highRiskThreshold).length;
                    const belowMediumRisk = dataArray.filter(v => v < mediumRiskThreshold).length;
                    
                    const highRiskPercentage = (belowHighRisk / dataArray.length) * 100;
                    const mediumRiskPercentage = (belowMediumRisk / dataArray.length) * 100;
                    
                    if (highRiskPercentage > 15) { // Too many flagged as high risk
                        fit = 'too_strict';
                        adjustment = 'lower_thresholds';
                        recommended[0] = Math.max(p10 - 5, 0); // More conservative
                        recommended[1] = Math.max(p25 - 5, recommended[0] + 5);
                    } else if (highRiskPercentage < 3) { // Too few flagged
                        fit = 'too_lenient';
                        adjustment = 'raise_thresholds';
                        recommended[0] = Math.min(p10 + 5, recommended[1] - 5);
                    }
                    
                    if (mediumRiskPercentage > 30) { // Too many medium risk
                        recommended[1] = Math.max(p25 - 3, recommended[0] + 5);
                    }
                    
                } else if (paramType === 'time' || paramType === 'taps') {
                    // For time and taps, higher values are worse
                    const mediumRiskThreshold = thresholds[thresholds.length - 2] || thresholds[0];
                    const highRiskThreshold = thresholds[thresholds.length - 1];
                    
                    // Check if too many normal users are being flagged
                    const aboveMediumRisk = dataArray.filter(v => v > mediumRiskThreshold).length;
                    const aboveHighRisk = dataArray.filter(v => v > highRiskThreshold).length;
                    
                    const mediumRiskPercentage = (aboveMediumRisk / dataArray.length) * 100;
                    const highRiskPercentage = (aboveHighRisk / dataArray.length) * 100;
                    
                    if (highRiskPercentage > 15) { // Too many flagged as high risk
                        fit = 'too_strict';
                        adjustment = 'raise_thresholds';
                        recommended[recommended.length - 1] = Math.min(p90 + mean * 0.2, p90 * 1.5);
                        if (recommended.length > 1) {
                            recommended[recommended.length - 2] = Math.min(p75 + mean * 0.1, recommended[recommended.length - 1] - 20);
                        }
                    } else if (highRiskPercentage < 3) { // Too few flagged
                        fit = 'too_lenient';
                        adjustment = 'lower_thresholds';
                        recommended[recommended.length - 1] = Math.max(p75 + 10, mean + 20);
                    }
                }
                
                return {
                    current: {
                        mean: mean,
                        median: median,
                        p10: p10,
                        p25: p25,
                        p75: p75,
                        p90: p90,
                        originalThresholds: thresholds
                    },
                    recommended: recommended,
                    fit: fit,
                    adjustment: adjustment,
                    flaggedPercentages: {
                        highRisk: paramType === 'score' || paramType === 'accuracy' ? 
                            (dataArray.filter(v => v < thresholds[0]).length / dataArray.length) * 100 :
                            (dataArray.filter(v => v > thresholds[thresholds.length - 1]).length / dataArray.length) * 100,
                        mediumRisk: paramType === 'score' || paramType === 'accuracy' ? 
                            (dataArray.filter(v => v < thresholds[1] && v >= thresholds[0]).length / dataArray.length) * 100 :
                            (dataArray.filter(v => v > thresholds[thresholds.length - 2] && v <= thresholds[thresholds.length - 1]).length / dataArray.length) * 100
                    }
                };
            }
            
            function displayAnalysisResults(performanceStats, calibratedThresholds, allQuizData) {
                const reportContainer = document.getElementById('report-container');
                
                let analysisHTML = `
                    <div class="data-analysis-section">
                        <h2>📊 Quiz Performance Data Analysis</h2>
                        <p>Comprehensive analysis of ${Object.keys(allQuizData).length} quiz types with real user data</p>
                        
                        <div class="analysis-controls">
                            <button onclick="loadQuizReports()" class="btn-secondary">← Back to Reports</button>
                            <button onclick="applyCalibratedThresholds()" class="btn-primary">Apply Calibrated Thresholds</button>
                        </div>
                        
                        <div class="quiz-analysis-grid">
                `;
                
                Object.entries(performanceStats).forEach(([quizType, stats]) => {
                    const displayName = quizNames[quizType] || quizType;
                    const thresholds = calibratedThresholds[quizType];
                    
                    // Determine overall fit status
                    const fitStatuses = [thresholds.score.fit];
                    if (thresholds.time) fitStatuses.push(thresholds.time.fit);
                    if (thresholds.accuracy) fitStatuses.push(thresholds.accuracy.fit);
                    if (thresholds.taps) fitStatuses.push(thresholds.taps.fit);
                    
                    const hasConcerns = fitStatuses.some(f => f !== 'good');
                    const cardClass = hasConcerns ? 'quiz-analysis-card needs-attention' : 'quiz-analysis-card';
                    
                    analysisHTML += `
                        <div class="${cardClass}">
                            <h3>${displayName} ${hasConcerns ? '⚠️' : '✅'}</h3>
                            <div class="stats-summary">
                                <p><strong>Total Attempts:</strong> ${stats.totalAttempts}</p>
                                
                                <div class="stat-group">
                                    <h4>📈 Scores</h4>
                                    <p>Mean: ${stats.scores.mean.toFixed(1)}% | Median: ${stats.scores.median.toFixed(1)}%</p>
                                    <p>Range: ${stats.scores.min}% - ${stats.scores.max}%</p>
                                    <p>10th percentile: ${stats.scores.p10.toFixed(1)}% | 25th percentile: ${stats.scores.p25.toFixed(1)}%</p>
                                    
                                    <div class="current-vs-recommended">
                                        <div class="current-thresholds">
                                            <strong>Current Thresholds:</strong><br>
                                            High Risk: < ${thresholds.score.current.originalThresholds[0]}% | 
                                            Medium Risk: < ${thresholds.score.current.originalThresholds[1]}%
                                        </div>
                                        
                                        <div class="threshold-recommendation ${thresholds.score.fit !== 'good' ? 'needs-adjustment' : 'good-fit'}">
                                            <strong>Analysis: ${getFitDescription(thresholds.score.fit)}</strong><br>
                                            ${thresholds.score.fit !== 'good' ? `
                                                <span class="adjustment-needed">Recommended Adjustments:</span><br>
                                                High Risk: < ${thresholds.score.recommended[0].toFixed(1)}% | 
                                                Medium Risk: < ${thresholds.score.recommended[1].toFixed(1)}%<br>
                                                <small>Currently flagging ${thresholds.score.flaggedPercentages ? thresholds.score.flaggedPercentages.highRisk.toFixed(1) : 'N/A'}% as high risk</small>
                                            ` : `
                                                <span class="good-fit-text">Current thresholds are well-calibrated for this data</span>
                                            `}
                                        </div>
                                    </div>
                                </div>
                                
                                ${stats.times && thresholds.time ? `
                                <div class="stat-group">
                                    <h4>⏱️ Time (seconds)</h4>
                                    <p>Mean: ${stats.times.mean.toFixed(1)}s | Median: ${stats.times.median.toFixed(1)}s</p>
                                    <p>75th percentile: ${stats.times.p75.toFixed(1)}s | 90th percentile: ${stats.times.p90.toFixed(1)}s</p>
                                    
                                    <div class="current-vs-recommended">
                                        <div class="current-thresholds">
                                            <strong>Current Thresholds:</strong><br>
                                            ${thresholds.time.current.originalThresholds.map((t, i) => 
                                                i === thresholds.time.current.originalThresholds.length - 1 ? `High Risk: > ${t}s` :
                                                i === thresholds.time.current.originalThresholds.length - 2 ? `Medium Risk: > ${t}s` :
                                                `Mild: > ${t}s`
                                            ).join(' | ')}
                                        </div>
                                        
                                        <div class="threshold-recommendation ${thresholds.time.fit !== 'good' ? 'needs-adjustment' : 'good-fit'}">
                                            <strong>Analysis: ${getFitDescription(thresholds.time.fit)}</strong><br>
                                            ${thresholds.time.fit !== 'good' ? `
                                                <span class="adjustment-needed">Recommended Adjustments:</span><br>
                                                ${thresholds.time.recommended.map((t, i) => 
                                                    i === thresholds.time.recommended.length - 1 ? `High Risk: > ${t.toFixed(1)}s` :
                                                    i === thresholds.time.recommended.length - 2 ? `Medium Risk: > ${t.toFixed(1)}s` :
                                                    `Mild: > ${t.toFixed(1)}s`
                                                ).join(' | ')}<br>
                                                <small>Currently flagging ${thresholds.time.flaggedPercentages ? thresholds.time.flaggedPercentages.highRisk.toFixed(1) : 'N/A'}% as high risk</small>
                                            ` : `
                                                <span class="good-fit-text">Current thresholds are well-calibrated for this data</span>
                                            `}
                                        </div>
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${stats.accuracies && thresholds.accuracy ? `
                                <div class="stat-group">
                                    <h4>🎯 Accuracy</h4>
                                    <p>Mean: ${stats.accuracies.mean.toFixed(1)}% | Median: ${stats.accuracies.median.toFixed(1)}%</p>
                                    <p>10th percentile: ${stats.accuracies.p10.toFixed(1)}% | 25th percentile: ${stats.accuracies.p25.toFixed(1)}%</p>
                                    
                                    <div class="current-vs-recommended">
                                        <div class="current-thresholds">
                                            <strong>Current Thresholds:</strong><br>
                                            High Risk: < ${thresholds.accuracy.current.originalThresholds[0]}% | 
                                            Medium Risk: < ${thresholds.accuracy.current.originalThresholds[1]}%
                                        </div>
                                        
                                        <div class="threshold-recommendation ${thresholds.accuracy.fit !== 'good' ? 'needs-adjustment' : 'good-fit'}">
                                            <strong>Analysis: ${getFitDescription(thresholds.accuracy.fit)}</strong><br>
                                            ${thresholds.accuracy.fit !== 'good' ? `
                                                <span class="adjustment-needed">Recommended Adjustments:</span><br>
                                                High Risk: < ${thresholds.accuracy.recommended[0].toFixed(1)}% | 
                                                Medium Risk: < ${thresholds.accuracy.recommended[1].toFixed(1)}%<br>
                                                <small>Currently flagging ${thresholds.accuracy.flaggedPercentages ? thresholds.accuracy.flaggedPercentages.highRisk.toFixed(1) : 'N/A'}% as high risk</small>
                                            ` : `
                                                <span class="good-fit-text">Current thresholds are well-calibrated for this data</span>
                                            `}
                                        </div>
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${stats.taps && thresholds.taps ? `
                                <div class="stat-group">
                                    <h4>👆 Interactions</h4>
                                    <p>Mean: ${stats.taps.mean.toFixed(1)} | Median: ${stats.taps.median.toFixed(1)}</p>
                                    <p>75th percentile: ${stats.taps.p75.toFixed(1)} | 90th percentile: ${stats.taps.p90.toFixed(1)}</p>
                                    
                                    <div class="current-vs-recommended">
                                        <div class="current-thresholds">
                                            <strong>Current Thresholds:</strong><br>
                                            ${thresholds.taps.current.originalThresholds.map((t, i) => 
                                                i === thresholds.taps.current.originalThresholds.length - 1 ? `High Risk: > ${t}` :
                                                `Medium Risk: > ${t}`
                                            ).join(' | ')}
                                        </div>
                                        
                                        <div class="threshold-recommendation ${thresholds.taps.fit !== 'good' ? 'needs-adjustment' : 'good-fit'}">
                                            <strong>Analysis: ${getFitDescription(thresholds.taps.fit)}</strong><br>
                                            ${thresholds.taps.fit !== 'good' ? `
                                                <span class="adjustment-needed">Recommended Adjustments:</span><br>
                                                ${thresholds.taps.recommended.map((t, i) => 
                                                    i === thresholds.taps.recommended.length - 1 ? `High Risk: > ${t.toFixed(1)}` :
                                                    `Medium Risk: > ${t.toFixed(1)}`
                                                ).join(' | ')}<br>
                                                <small>Currently flagging ${thresholds.taps.flaggedPercentages ? thresholds.taps.flaggedPercentages.highRisk.toFixed(1) : 'N/A'}% as high risk</small>
                                            ` : `
                                                <span class="good-fit-text">Current thresholds are well-calibrated for this data</span>
                                            `}
                                        </div>
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });
                
                analysisHTML += `
                        </div>
                        
                        <div class="analysis-summary">
                            <h3>📋 Quiz-Specific Threshold Analysis Summary</h3>
                            <p>This analysis examined real quiz performance data against existing CVI risk assessment thresholds for each specific quiz type.</p>
                            <p><strong>Methodology:</strong></p>
                            <ul>
                                <li><strong>Quiz-Specific Parameters:</strong> Each quiz has tailored thresholds based on its difficulty and expected performance ranges</li>
                                <li><strong>Data Fit Analysis:</strong> Compares actual user performance against current thresholds to identify over/under-flagging</li>
                                <li><strong>Calibration Goals:</strong> High risk should flag ~3-10% of users, Medium risk ~10-25% of users</li>
                                <li><strong>Evidence-Based Adjustments:</strong> Recommendations based on statistical analysis of real user data</li>
                            </ul>
                            <p><strong>Interpretation:</strong></p>
                            <ul>
                                <li>✅ <strong>Good Fit:</strong> Current thresholds are well-calibrated for the data</li>
                                <li>⚠️ <strong>Too Strict:</strong> Flagging too many normal users as high/medium risk</li>
                                <li>⚠️ <strong>Too Lenient:</strong> Not flagging enough users who may have CVI concerns</li>
                            </ul>
                            <p>Use the recommended adjustments to fine-tune CVI risk assessment accuracy for each quiz type.</p>
                        </div>
                    </div>
                `;
                
                // Helper function for fit descriptions
                function getFitDescription(fit) {
                    switch(fit) {
                        case 'good': return 'Well-Calibrated';
                        case 'too_strict': return 'Too Strict (Over-flagging)';
                        case 'too_lenient': return 'Too Lenient (Under-flagging)';
                        default: return 'Unknown';
                    }
                }
                
                reportContainer.innerHTML = analysisHTML;
                
                // Store calibrated thresholds globally for potential application
                window.calibratedThresholds = calibratedThresholds;
                window.performanceStats = performanceStats;
                
                console.log('📊 Analysis complete! Calibrated thresholds:', calibratedThresholds);
            }
            
            // ADAPTIVE THRESHOLD SYSTEM WITH PERSISTENT STORAGE
            
            // Initialize adaptive threshold system
            async function initializeAdaptiveThresholds() {
                try {
                    // Check if stored standards exist
                    const storedStandards = await database.ref('system/adaptiveThresholds').once('value');
                    if (storedStandards.exists()) {
                        window.adaptiveStandards = storedStandards.val();
                        console.log('📊 Loaded existing adaptive standards:', window.adaptiveStandards);
                    } else {
                        console.log('📊 No existing standards found. Will create new ones.');
                        window.adaptiveStandards = null;
                    }
                } catch (error) {
                    console.error('Error loading adaptive standards:', error);
                }
            }
            
            // Comprehensive cross-user analysis for each quiz type
            async function analyzeAndUpdateAdaptiveStandards() {
                console.log('🔬 Starting comprehensive cross-user adaptive analysis...');
                
                const reportContainer = document.getElementById('report-container');
                reportContainer.innerHTML = '<div class="loading">🔬 Analyzing all user data across quiz types... This may take a moment.</div>';
                
                try {
                    // Collect ALL user data across the platform
                    const allQuizData = await collectAllUserData();
                    
                    // Analyze each quiz type across all users
                    const adaptiveStandards = await generateAdaptiveStandards(allQuizData);
                    
                    // Store the standards in Firebase for persistence
                    await storeAdaptiveStandards(adaptiveStandards);
                    
                    // Update global standards
                    window.adaptiveStandards = adaptiveStandards;
                    
                    // Display comprehensive analysis results
                    displayAdaptiveAnalysis(adaptiveStandards, allQuizData);
                    
                } catch (error) {
                    console.error('Error in adaptive analysis:', error);
                    reportContainer.innerHTML = '<div class="error">Error during adaptive analysis. Please try again.</div>';
                }
            }
            
            // Collect all user data from Firebase
            async function collectAllUserData() {
                const allData = {};
                
                // Get all users data
                const usersSnapshot = await database.ref('users').once('value');
                const usersData = usersSnapshot.val() || {};
                
                // Get all doctors and their patients data
                const doctorsSnapshot = await database.ref('doctors').once('value');
                const doctorsData = doctorsSnapshot.val() || {};
                
                console.log(`📊 Collecting data from ${Object.keys(usersData).length} users and ${Object.keys(doctorsData).length} doctors`);
                
                // Process users data
                Object.entries(usersData).forEach(([userId, userData]) => {
                    if (userData.quiz) {
                        processUserDataForAdaptive(userData.quiz, userId, 'user', allData);
                    }
                    if (userData.quizzes) {
                        processUserDataForAdaptive(userData.quizzes, userId, 'user', allData);
                    }
                });
                
                // Process doctors' patients data
                Object.entries(doctorsData).forEach(([doctorId, doctorData]) => {
                    if (doctorData.patients) {
                        Object.entries(doctorData.patients).forEach(([patientId, patientData]) => {
                            if (patientData.quiz) {
                                processUserDataForAdaptive(patientData.quiz, patientId, 'patient', allData);
                            }
                            if (patientData.quizzes) {
                                processUserDataForAdaptive(patientData.quizzes, patientId, 'patient', allData);
                            }
                        });
                    }
                });
                
                return allData;
            }
            
            function processUserDataForAdaptive(quizData, userId, userType, allData) {
                Object.entries(quizData).forEach(([quizType, quizTypeData]) => {
                    if (!allData[quizType]) {
                        allData[quizType] = [];
                    }
                    
                    // Extract all attempts for this quiz type
                    const attempts = extractAllAttempts(quizTypeData, quizType);
                    attempts.forEach(attempt => {
                        // Add metadata for better analysis
                        allData[quizType].push({
                            ...attempt,
                            userId,
                            userType,
                            quizType,
                            timestamp: attempt.timestamp || Date.now(),
                            // Normalize data
                            normalizedScore: Math.max(0, Math.min(100, attempt.score || 0)),
                            normalizedTime: Math.max(0, (attempt.timeSpent || 0) / 1000),
                            normalizedAccuracy: Math.max(0, Math.min(100, attempt.accuracy || 0)),
                            normalizedTaps: Math.max(0, attempt.totalTaps || attempt.totalClicks || 0)
                        });
                    });
                });
            }
            
            // Generate adaptive standards based on comprehensive analysis
            async function generateAdaptiveStandards(allQuizData) {
                const standards = {
                    lastUpdated: Date.now(),
                    totalUsers: new Set(),
                    quizStandards: {}
                };
                
                // Count unique users
                Object.values(allQuizData).forEach(attempts => {
                    attempts.forEach(attempt => standards.totalUsers.add(attempt.userId));
                });
                standards.totalUsers = standards.totalUsers.size;
                
                // Analyze each quiz type
                Object.entries(allQuizData).forEach(([quizType, attempts]) => {
                    if (attempts.length < 10) { // Need minimum data for reliable analysis
                        console.warn(`⚠️ Insufficient data for ${quizType}: ${attempts.length} attempts`);
                        return;
                    }
                    
                    const analysis = performComprehensiveQuizAnalysis(quizType, attempts);
                    standards.quizStandards[quizType] = analysis;
                });
                
                return standards;
            }
            
            function performComprehensiveQuizAnalysis(quizType, attempts) {
                const scores = attempts.map(a => a.normalizedScore).filter(s => s >= 0);
                const times = attempts.map(a => a.normalizedTime).filter(t => t > 0);
                const accuracies = attempts.map(a => a.normalizedAccuracy).filter(a => a >= 0);
                const taps = attempts.map(a => a.normalizedTaps).filter(t => t >= 0);
                
                // Statistical analysis
                const scoreStats = calculateDetailedStats(scores);
                const timeStats = times.length > 0 ? calculateDetailedStats(times) : null;
                const accuracyStats = accuracies.length > 0 ? calculateDetailedStats(accuracies) : null;
                const tapStats = taps.length > 0 ? calculateDetailedStats(taps) : null;
                
                // Determine optimal thresholds using multiple methods
                const optimalThresholds = determineOptimalThresholds(quizType, {
                    scores: scoreStats,
                    times: timeStats,
                    accuracies: accuracyStats,
                    taps: tapStats
                });
                
                // Performance classification
                const performanceDistribution = classifyPerformanceLevels(attempts, optimalThresholds);
                
                return {
                    quizType,
                    totalAttempts: attempts.length,
                    uniqueUsers: new Set(attempts.map(a => a.userId)).size,
                    dataQuality: assessDataQuality(attempts),
                    statistics: {
                        scores: scoreStats,
                        times: timeStats,
                        accuracies: accuracyStats,
                        taps: tapStats
                    },
                    optimalThresholds,
                    performanceDistribution,
                    confidence: calculateConfidenceLevel(attempts.length),
                    lastAnalyzed: Date.now()
                };
            }
            
            function calculateDetailedStats(data) {
                if (data.length === 0) return null;
                
                const sorted = [...data].sort((a, b) => a - b);
                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
                const std = Math.sqrt(variance);
                
                return {
                    count: data.length,
                    min: Math.min(...data),
                    max: Math.max(...data),
                    mean: mean,
                    median: getMedian(data),
                    std: std,
                    variance: variance,
                    percentiles: {
                        p5: getPercentile(data, 5),
                        p10: getPercentile(data, 10),
                        p25: getPercentile(data, 25),
                        p50: getPercentile(data, 50),
                        p75: getPercentile(data, 75),
                        p90: getPercentile(data, 90),
                        p95: getPercentile(data, 95)
                    },
                    outliers: detectOutliers(data),
                    distribution: analyzeDistribution(data)
                };
            }
            
            function determineOptimalThresholds(quizType, stats) {
                const thresholds = {
                    score: null,
                    time: null,
                    accuracy: null,
                    taps: null,
                    riskClassification: {
                        highRisk: { description: 'Severe impairment indicators', targetPercentage: 5 },
                        mediumRisk: { description: 'Moderate concern indicators', targetPercentage: 15 },
                        lowRisk: { description: 'Normal performance range', targetPercentage: 80 }
                    }
                };
                
                // Score thresholds (lower = worse)
                if (stats.scores) {
                    thresholds.score = {
                        highRisk: Math.max(0, stats.scores.percentiles.p5),
                        mediumRisk: Math.max(thresholds.score?.highRisk || 0, stats.scores.percentiles.p15 || stats.scores.percentiles.p10),
                        lowRisk: Math.max(thresholds.score?.mediumRisk || 0, stats.scores.percentiles.p25),
                        optimal: stats.scores.percentiles.p75,
                        excellent: stats.scores.percentiles.p90
                    };
                }
                
                // Time thresholds (higher = worse)
                if (stats.times) {
                    thresholds.time = {
                        excellent: stats.times.percentiles.p25,
                        optimal: stats.times.percentiles.p50,
                        lowRisk: stats.times.percentiles.p75,
                        mediumRisk: stats.times.percentiles.p85 || stats.times.percentiles.p90,
                        highRisk: stats.times.percentiles.p95
                    };
                }
                
                // Accuracy thresholds (lower = worse)
                if (stats.accuracies) {
                    thresholds.accuracy = {
                        highRisk: Math.max(0, stats.accuracies.percentiles.p5),
                        mediumRisk: Math.max(thresholds.accuracy?.highRisk || 0, stats.accuracies.percentiles.p15 || stats.accuracies.percentiles.p10),
                        lowRisk: Math.max(thresholds.accuracy?.mediumRisk || 0, stats.accuracies.percentiles.p25),
                        optimal: stats.accuracies.percentiles.p75,
                        excellent: stats.accuracies.percentiles.p90
                    };
                }
                
                // Tap thresholds (higher = worse, indicates uncertainty)
                if (stats.taps) {
                    thresholds.taps = {
                        excellent: stats.taps.percentiles.p25,
                        optimal: stats.taps.percentiles.p50,
                        lowRisk: stats.taps.percentiles.p75,
                        mediumRisk: stats.taps.percentiles.p85 || stats.taps.percentiles.p90,
                        highRisk: stats.taps.percentiles.p95
                    };
                }
                
                return thresholds;
            }
            
            function classifyPerformanceLevels(attempts, thresholds) {
                const distribution = {
                    excellent: 0,
                    optimal: 0,
                    lowRisk: 0,
                    mediumRisk: 0,
                    highRisk: 0
                };
                
                attempts.forEach(attempt => {
                    const classification = classifyAttempt(attempt, thresholds);
                    distribution[classification]++;
                });
                
                const total = attempts.length;
                return {
                    counts: distribution,
                    percentages: {
                        excellent: (distribution.excellent / total) * 100,
                        optimal: (distribution.optimal / total) * 100,
                        lowRisk: (distribution.lowRisk / total) * 100,
                        mediumRisk: (distribution.mediumRisk / total) * 100,
                        highRisk: (distribution.highRisk / total) * 100
                    }
                };
            }
            
            function classifyAttempt(attempt, thresholds) {
                let riskScore = 0;
                
                // Score assessment
                if (thresholds.score && attempt.normalizedScore !== undefined) {
                    if (attempt.normalizedScore < thresholds.score.highRisk) riskScore += 4;
                    else if (attempt.normalizedScore < thresholds.score.mediumRisk) riskScore += 2;
                    else if (attempt.normalizedScore >= thresholds.score.excellent) riskScore -= 2;
                    else if (attempt.normalizedScore >= thresholds.score.optimal) riskScore -= 1;
                }
                
                // Time assessment
                if (thresholds.time && attempt.normalizedTime !== undefined) {
                    if (attempt.normalizedTime > thresholds.time.highRisk) riskScore += 3;
                    else if (attempt.normalizedTime > thresholds.time.mediumRisk) riskScore += 2;
                    else if (attempt.normalizedTime <= thresholds.time.excellent) riskScore -= 2;
                    else if (attempt.normalizedTime <= thresholds.time.optimal) riskScore -= 1;
                }
                
                // Accuracy assessment
                if (thresholds.accuracy && attempt.normalizedAccuracy !== undefined) {
                    if (attempt.normalizedAccuracy < thresholds.accuracy.highRisk) riskScore += 3;
                    else if (attempt.normalizedAccuracy < thresholds.accuracy.mediumRisk) riskScore += 2;
                    else if (attempt.normalizedAccuracy >= thresholds.accuracy.excellent) riskScore -= 2;
                    else if (attempt.normalizedAccuracy >= thresholds.accuracy.optimal) riskScore -= 1;
                }
                
                // Tap assessment
                if (thresholds.taps && attempt.normalizedTaps !== undefined) {
                    if (attempt.normalizedTaps > thresholds.taps.highRisk) riskScore += 2;
                    else if (attempt.normalizedTaps > thresholds.taps.mediumRisk) riskScore += 1;
                    else if (attempt.normalizedTaps <= thresholds.taps.excellent) riskScore -= 1;
                }
                
                // Classify based on total risk score
                if (riskScore >= 8) return 'highRisk';
                if (riskScore >= 4) return 'mediumRisk';
                if (riskScore <= -3) return 'excellent';
                if (riskScore <= -1) return 'optimal';
                return 'lowRisk';
            }
            
            function assessDataQuality(attempts) {
                const uniqueUsers = new Set(attempts.map(a => a.userId)).size;
                const timeSpread = attempts.length > 1 ? 
                    Math.max(...attempts.map(a => a.timestamp)) - Math.min(...attempts.map(a => a.timestamp)) : 0;
                
                let quality = 'good';
                if (attempts.length < 20) quality = 'limited';
                if (uniqueUsers < 5) quality = 'insufficient';
                if (attempts.length > 100 && uniqueUsers > 20) quality = 'excellent';
                
                return {
                    level: quality,
                    totalAttempts: attempts.length,
                    uniqueUsers: uniqueUsers,
                    timeSpanDays: Math.round(timeSpread / (1000 * 60 * 60 * 24)),
                    avgAttemptsPerUser: attempts.length / uniqueUsers
                };
            }
            
            function calculateConfidenceLevel(sampleSize) {
                if (sampleSize < 10) return 'very_low';
                if (sampleSize < 30) return 'low';
                if (sampleSize < 100) return 'moderate';
                if (sampleSize < 500) return 'high';
                return 'very_high';
            }
            
            function detectOutliers(data) {
                const q1 = getPercentile(data, 25);
                const q3 = getPercentile(data, 75);
                const iqr = q3 - q1;
                const lowerBound = q1 - 1.5 * iqr;
                const upperBound = q3 + 1.5 * iqr;
                
                return {
                    count: data.filter(v => v < lowerBound || v > upperBound).length,
                    percentage: (data.filter(v => v < lowerBound || v > upperBound).length / data.length) * 100,
                    lowerBound,
                    upperBound
                };
            }
            
            function analyzeDistribution(data) {
                const mean = data.reduce((a, b) => a + b, 0) / data.length;
                const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
                const skewness = data.reduce((a, b) => a + Math.pow(b - mean, 3), 0) / (data.length * Math.pow(variance, 1.5));
                
                let shape = 'normal';
                if (Math.abs(skewness) > 1) shape = skewness > 0 ? 'right_skewed' : 'left_skewed';
                else if (Math.abs(skewness) > 0.5) shape = skewness > 0 ? 'moderately_right_skewed' : 'moderately_left_skewed';
                
                return {
                    shape,
                    skewness,
                    variance
                };
            }
            
            // Store adaptive standards in Firebase
            async function storeAdaptiveStandards(standards) {
                try {
                    await database.ref('system/adaptiveThresholds').set(standards);
                    console.log('✅ Adaptive standards stored successfully');
                } catch (error) {
                    console.error('Error storing adaptive standards:', error);
                    throw error;
                }
            }
            
            // Apply stored adaptive standards to current CVI risk assessment
            function applyAdaptiveStandards() {
                if (!window.adaptiveStandards) {
                    alert('No adaptive standards available. Please run the analysis first.');
                    return;
                }
                
                console.log('🔧 Applying adaptive standards...', window.adaptiveStandards);
                
                // Update the global CVI assessment function to use adaptive standards
                window.useAdaptiveStandards = true;
                
                alert(`✅ Adaptive standards applied successfully!\n\nStandards based on ${window.adaptiveStandards.totalUsers} users across ${Object.keys(window.adaptiveStandards.quizStandards).length} quiz types.\n\nThe CVI risk assessment will now use these evidence-based thresholds.`);
                
                // Optionally reload the reports to show updated classifications
                if (confirm('Would you like to reload the reports to see the updated CVI risk classifications?')) {
                    loadQuizReports();
                }
            }
            
            // Display comprehensive adaptive analysis results
            function displayAdaptiveAnalysis(adaptiveStandards, allQuizData) {
                const reportContainer = document.getElementById('report-container');
                
                const totalQuizTypes = Object.keys(adaptiveStandards.quizStandards).length;
                const totalAttempts = Object.values(allQuizData).reduce((sum, attempts) => sum + attempts.length, 0);
                
                let analysisHTML = `
                    <div class="adaptive-analysis-section">
                        <h2>🤖 Adaptive CVI Standards Analysis</h2>
                        <div class="analysis-overview">
                            <div class="overview-stats">
                                <div class="stat-card">
                                    <h3>${adaptiveStandards.totalUsers}</h3>
                                    <p>Total Users Analyzed</p>
                                </div>
                                <div class="stat-card">
                                    <h3>${totalQuizTypes}</h3>
                                    <p>Quiz Types with Standards</p>
                                </div>
                                <div class="stat-card">
                                    <h3>${totalAttempts.toLocaleString()}</h3>
                                    <p>Total Quiz Attempts</p>
                                </div>
                                <div class="stat-card">
                                    <h3>${new Date(adaptiveStandards.lastUpdated).toLocaleDateString()}</h3>
                                    <p>Last Updated</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="analysis-controls">
                            <button onclick="loadQuizReports()" class="btn-secondary">← Back to Reports</button>
                            <button onclick="applyAdaptiveStandards()" class="btn-primary">✅ Apply Adaptive Standards</button>
                            <button onclick="analyzeAndUpdateAdaptiveStandards()" class="btn-primary">🔄 Reanalyze & Update</button>
                        </div>
                        
                        <div class="adaptive-quiz-grid">
                `;
                
                // Sort quiz types by confidence level and data quality
                const sortedQuizTypes = Object.entries(adaptiveStandards.quizStandards)
                    .sort((a, b) => {
                        const aQuality = getQualityScore(a[1]);
                        const bQuality = getQualityScore(b[1]);
                        return bQuality - aQuality;
                    });
                
                sortedQuizTypes.forEach(([quizType, standards]) => {
                    const displayName = quizNames[quizType] || quizType;
                    const qualityLevel = standards.dataQuality.level;
                    const confidence = standards.confidence;
                    
                    const cardClass = getAdaptiveCardClass(qualityLevel, confidence);
                    const qualityIcon = getQualityIcon(qualityLevel);
                    const confidenceIcon = getConfidenceIcon(confidence);
                    
                    analysisHTML += `
                        <div class="${cardClass}">
                            <h3>${displayName} ${qualityIcon} ${confidenceIcon}</h3>
                            <div class="adaptive-stats-summary">
                                <div class="data-quality-info">
                                    <p><strong>Data Quality:</strong> ${qualityLevel.toUpperCase()} (${standards.totalAttempts} attempts from ${standards.uniqueUsers} users)</p>
                                    <p><strong>Confidence:</strong> ${confidence.replace('_', ' ').toUpperCase()}</p>
                                </div>
                                
                                <div class="performance-distribution">
                                    <h4>📈 Performance Distribution</h4>
                                    <div class="distribution-bars">
                                        <div class="dist-bar excellent" style="width: ${standards.performanceDistribution.percentages.excellent.toFixed(1)}%">
                                            <span>Excellent: ${standards.performanceDistribution.percentages.excellent.toFixed(1)}%</span>
                                        </div>
                                        <div class="dist-bar optimal" style="width: ${standards.performanceDistribution.percentages.optimal.toFixed(1)}%">
                                            <span>Optimal: ${standards.performanceDistribution.percentages.optimal.toFixed(1)}%</span>
                                        </div>
                                        <div class="dist-bar low-risk" style="width: ${standards.performanceDistribution.percentages.lowRisk.toFixed(1)}%">
                                            <span>Low Risk: ${standards.performanceDistribution.percentages.lowRisk.toFixed(1)}%</span>
                                        </div>
                                        <div class="dist-bar medium-risk" style="width: ${standards.performanceDistribution.percentages.mediumRisk.toFixed(1)}%">
                                            <span>Medium Risk: ${standards.performanceDistribution.percentages.mediumRisk.toFixed(1)}%</span>
                                        </div>
                                        <div class="dist-bar high-risk" style="width: ${standards.performanceDistribution.percentages.highRisk.toFixed(1)}%">
                                            <span>High Risk: ${standards.performanceDistribution.percentages.highRisk.toFixed(1)}%</span>
                                        </div>
                                    </div>
                                </div>
                                
                                ${standards.statistics.scores ? `
                                <div class="adaptive-stat-group">
                                    <h4>📈 Score Thresholds</h4>
                                    <div class="threshold-display">
                                        <div class="threshold-item high-risk">High Risk: < ${standards.optimalThresholds.score.highRisk.toFixed(1)}%</div>
                                        <div class="threshold-item medium-risk">Medium Risk: < ${standards.optimalThresholds.score.mediumRisk.toFixed(1)}%</div>
                                        <div class="threshold-item low-risk">Low Risk: ≥ ${standards.optimalThresholds.score.lowRisk.toFixed(1)}%</div>
                                    </div>
                                    <p class="stats-detail">Mean: ${standards.statistics.scores.mean.toFixed(1)}% | Median: ${standards.statistics.scores.median.toFixed(1)}% | Std: ${standards.statistics.scores.std.toFixed(1)}</p>
                                </div>
                                ` : ''}
                                
                                ${standards.statistics.times ? `
                                <div class="adaptive-stat-group">
                                    <h4>⏱️ Time Thresholds</h4>
                                    <div class="threshold-display">
                                        <div class="threshold-item high-risk">High Risk: > ${standards.optimalThresholds.time.highRisk.toFixed(1)}s</div>
                                        <div class="threshold-item medium-risk">Medium Risk: > ${standards.optimalThresholds.time.mediumRisk.toFixed(1)}s</div>
                                        <div class="threshold-item low-risk">Low Risk: ≤ ${standards.optimalThresholds.time.lowRisk.toFixed(1)}s</div>
                                    </div>
                                    <p class="stats-detail">Mean: ${standards.statistics.times.mean.toFixed(1)}s | Median: ${standards.statistics.times.median.toFixed(1)}s</p>
                                </div>
                                ` : ''}
                                
                                ${standards.statistics.accuracies ? `
                                <div class="adaptive-stat-group">
                                    <h4>🎯 Accuracy Thresholds</h4>
                                    <div class="threshold-display">
                                        <div class="threshold-item high-risk">High Risk: < ${standards.optimalThresholds.accuracy.highRisk.toFixed(1)}%</div>
                                        <div class="threshold-item medium-risk">Medium Risk: < ${standards.optimalThresholds.accuracy.mediumRisk.toFixed(1)}%</div>
                                        <div class="threshold-item low-risk">Low Risk: ≥ ${standards.optimalThresholds.accuracy.lowRisk.toFixed(1)}%</div>
                                    </div>
                                    <p class="stats-detail">Mean: ${standards.statistics.accuracies.mean.toFixed(1)}% | Median: ${standards.statistics.accuracies.median.toFixed(1)}%</p>
                                </div>
                                ` : ''}
                                
                                <div class="data-insights">
                                    <h4>🔍 Data Insights</h4>
                                    <ul>
                                        <li><strong>Distribution Shape:</strong> ${standards.statistics.scores?.distribution.shape.replace('_', ' ') || 'N/A'}</li>
                                        <li><strong>Outliers:</strong> ${standards.statistics.scores?.outliers.percentage.toFixed(1) || 'N/A'}% of scores</li>
                                        <li><strong>Time Span:</strong> ${standards.dataQuality.timeSpanDays} days of data</li>
                                        <li><strong>Avg Attempts/User:</strong> ${standards.dataQuality.avgAttemptsPerUser.toFixed(1)}</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                analysisHTML += `
                        </div>
                        
                        <div class="adaptive-summary">
                            <h3>📋 Adaptive Standards Summary</h3>
                            <p>This analysis created evidence-based CVI risk thresholds by analyzing <strong>${totalAttempts.toLocaleString()} quiz attempts</strong> from <strong>${adaptiveStandards.totalUsers} users</strong> across <strong>${totalQuizTypes} quiz types</strong>.</p>
                            
                            <div class="methodology-explanation">
                                <h4>Adaptive Methodology:</h4>
                                <ul>
                                    <li><strong>Cross-User Analysis:</strong> Analyzes each quiz type across ALL users to establish robust baselines</li>
                                    <li><strong>Statistical Rigor:</strong> Uses percentile-based thresholds (5th, 15th, 25th percentiles) for risk classification</li>
                                    <li><strong>Performance Distribution:</strong> Targets ~5% high risk, ~15% medium risk, ~80% low risk</li>
                                    <li><strong>Data Quality Assessment:</strong> Evaluates confidence based on sample size and user diversity</li>
                                    <li><strong>Persistent Storage:</strong> Standards are stored in Firebase and updated incrementally</li>
                                    <li><strong>Continuous Learning:</strong> System improves as more data becomes available</li>
                                </ul>
                            </div>
                            
                            <div class="confidence-explanation">
                                <h4>Confidence Levels:</h4>
                                <ul>
                                    <li>🔴 <strong>Very Low:</strong> < 10 attempts (insufficient data)</li>
                                    <li>🟠 <strong>Low:</strong> 10-29 attempts (limited reliability)</li>
                                    <li>🟡 <strong>Moderate:</strong> 30-99 attempts (reasonable confidence)</li>
                                    <li>🟢 <strong>High:</strong> 100-499 attempts (high confidence)</li>
                                    <li>🟢 <strong>Very High:</strong> 500+ attempts (excellent confidence)</li>
                                </ul>
                            </div>
                            
                            <p class="apply-instruction"><strong>Next Step:</strong> Click "Apply Adaptive Standards" to use these evidence-based thresholds for CVI risk assessment.</p>
                        </div>
                    </div>
                `;
                
                reportContainer.innerHTML = analysisHTML;
                
                console.log('🤖 Adaptive analysis complete! Standards ready for application.');
            }
            
            // Helper functions for adaptive analysis display
            function getQualityScore(standards) {
                const qualityScores = { 'excellent': 5, 'good': 4, 'limited': 2, 'insufficient': 1 };
                const confidenceScores = { 'very_high': 5, 'high': 4, 'moderate': 3, 'low': 2, 'very_low': 1 };
                return (qualityScores[standards.dataQuality.level] || 1) + (confidenceScores[standards.confidence] || 1);
            }
            
            function getAdaptiveCardClass(qualityLevel, confidence) {
                const baseClass = 'adaptive-quiz-card';
                if (qualityLevel === 'excellent' && (confidence === 'high' || confidence === 'very_high')) {
                    return `${baseClass} high-quality`;
                } else if (qualityLevel === 'insufficient' || confidence === 'very_low') {
                    return `${baseClass} low-quality`;
                }
                return `${baseClass} medium-quality`;
            }
            
            function getQualityIcon(qualityLevel) {
                const icons = {
                    'excellent': '🌟',
                    'good': '✅',
                    'limited': '⚠️',
                    'insufficient': '🔴'
                };
                return icons[qualityLevel] || '❓';
            }
            
            function getConfidenceIcon(confidence) {
                const icons = {
                    'very_high': '🟢',
                    'high': '🟢',
                    'moderate': '🟡',
                    'low': '🟠',
                    'very_low': '🔴'
                };
                return icons[confidence] || '❓';
            }
            
            // Update display of existing standards info
            function updateExistingStandardsDisplay() {
                const existingStandardsDiv = document.getElementById('existing-standards-info');
                const standardsInfoP = document.getElementById('standards-info');
                
                if (window.adaptiveStandards && existingStandardsDiv && standardsInfoP) {
                    const standards = window.adaptiveStandards;
                    const quizCount = Object.keys(standards.quizStandards).length;
                    const lastUpdated = new Date(standards.lastUpdated).toLocaleDateString();
                    
                    standardsInfoP.innerHTML = `
                        Standards available for <strong>${quizCount} quiz types</strong> based on <strong>${standards.totalUsers} users</strong>.<br>
                        Last updated: <strong>${lastUpdated}</strong>
                    `;
                    existingStandardsDiv.style.display = 'block';
                } else if (existingStandardsDiv) {
                    existingStandardsDiv.style.display = 'none';
                }
            }
            
            // Load quiz reports
            async function loadQuizReports() {
                try {
                    const user = auth.currentUser;
                    if (!user && !isPatientQuiz) return;
                    
                    const reportContainer = document.getElementById('report-container');
                    reportContainer.innerHTML = '<div class="loading" id="loading-message">Loading your quiz reports...</div>';
                    
                    // Comprehensive approach to get quiz data from all possible paths
                    const latestAttempts = {};
                    let dataFound = false;
                    
                    // Path 1: Check the 'quiz' path (most common pattern)
                    if (isPatientQuiz) {
                        // Doctor viewing patient - check both potential paths for patient data
                        try {
                            // First try the doctor's patients path
                            const quizSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/quiz`).once('value');
                            if (quizSnapshot.exists) {
                                console.log('Found quiz data in doctor/patients path');
                                await processQuizData(quizSnapshot.val(), latestAttempts);
                                dataFound = true;
                            }
                        } catch (error) {
                            console.warn('Error accessing quiz data in doctor/patients path:', error);
                        }
                        
                        // Also check the users path for the patient (some patients have data here)
                        try {
                            const userQuizSnapshot = await database.ref(`users/${currentPatientId}/quiz`).once('value');
                            if (userQuizSnapshot.exists) {
                                console.log('Found quiz data in users path for patient');
                                await processQuizData(userQuizSnapshot.val(), latestAttempts);
                                dataFound = true;
                            }
                        } catch (error) {
                            console.warn('Error accessing quiz data in users path for patient:', error);
                        }
                    } else {
                        // Regular user viewing their own reports
                        try {
                            const quizSnapshot = await database.ref(`users/${user.uid}/quiz`).once('value');
                            if (quizSnapshot.exists) {
                                console.log('Found quiz data in users/quiz path');
                                await processQuizData(quizSnapshot.val(), latestAttempts);
                                dataFound = true;
                            }
                        } catch (error) {
                            console.warn('Error accessing quiz data in users/quiz path:', error);
                        }
                    }
                    
                    // Path 2: Check the 'quizzes' path (alternate spelling used in some places)
                    if (isPatientQuiz) {
                        try {
                            const quizzesSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/quizzes`).once('value');
                            if (quizzesSnapshot.exists) {
                                console.log('Found quiz data in doctor/patients/quizzes path');
                                await processQuizData(quizzesSnapshot.val(), latestAttempts);
                                dataFound = true;
                            }
                        } catch (error) {
                            console.warn('Error accessing quiz data in doctor/patients/quizzes path:', error);
                        }
                    } else {
                        try {
                            const quizzesSnapshot = await database.ref(`users/${user.uid}/quizzes`).once('value');
                            if (quizzesSnapshot.exists) {
                                console.log('Found quiz data in users/quizzes path');
                                await processQuizData(quizzesSnapshot.val(), latestAttempts);
                                dataFound = true;
                            }
                        } catch (error) {
                            console.warn('Error accessing quiz data in users/quizzes path:', error);
                        }
                    }
                    
                    // Helper function to process quiz data and extract latest attempts
                    async function processQuizData(quizData, latestAttemptsMap) {
                        if (!quizData) return;
                        
                        console.log('Processing quiz data:', Object.keys(quizData));
                        
                        Object.keys(quizData).forEach(quizType => {
                            // Check if attempts exist directly under quiz type
                            if (quizData[quizType] && quizData[quizType].attempts) {
                                const attempts = Object.values(quizData[quizType].attempts);
                                if (attempts.length > 0) {
                                    // Sort attempts by timestamp (newest first)
                                    attempts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                                    
                                    // If we already have a latest attempt for this quiz type,
                                    // only update if this one is newer
                                    if (!latestAttemptsMap[quizType] || 
                                        (attempts[0].timestamp > latestAttemptsMap[quizType].timestamp)) {
                                        latestAttemptsMap[quizType] = attempts[0];
                                    }
                                }
                            } 
                            // Handle mirror assessment data with sub-branches
                            else if (quizType === 'mirror' && quizData[quizType] && typeof quizData[quizType] === 'object') {
                                console.log('Processing mirror data structure with sub-branches');
                                const attempts = [];
                                
                                // Process mirror data that has sub-branches
                                const processSubBranches = (branchData, prefix = '') => {
                                    if (!branchData || typeof branchData !== 'object') return;
                                    
                                    Object.entries(branchData).forEach(([key, value]) => {
                                        // If it's a timestamp entry (numeric key with object value)
                                        if (!isNaN(parseInt(key)) && value && typeof value === 'object') {
                                            attempts.push({
                                                ...value,
                                                timestamp: parseInt(key),
                                                path: prefix ? `${prefix}.${key}` : key
                                            });
                                        } 
                                        // If it's a sub-branch (non-numeric key with object value)
                                        else if (isNaN(parseInt(key)) && value && typeof value === 'object') {
                                            const newPrefix = prefix ? `${prefix}.${key}` : key;
                                            processSubBranches(value, newPrefix);
                                        }
                                    });
                                };
                                
                                processSubBranches(quizData[quizType]);
                                
                                if (attempts.length > 0) {
                                    console.log(`Found ${attempts.length} mirror attempts:`, attempts);
                                    // Sort attempts by timestamp (newest first)
                                    attempts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                                    
                                    if (!latestAttemptsMap[quizType] || 
                                        (attempts[0].timestamp > latestAttemptsMap[quizType].timestamp)) {
                                        latestAttemptsMap[quizType] = attempts[0];
                                    }
                                }
                            }
                            // Some quiz types might store attempts directly
                            else if (quizData[quizType] && typeof quizData[quizType] === 'object') {
                                const attempts = [];
                                
                                // Check if the structure is timestamp -> attempt data
                                Object.entries(quizData[quizType]).forEach(([key, value]) => {
                                    if (!isNaN(parseInt(key)) && value && typeof value === 'object') {
                                        // This appears to be a timestamp entry
                                        attempts.push({
                                            ...value,
                                            timestamp: parseInt(key)
                                        });
                                    }
                                });
                                
                                if (attempts.length > 0) {
                                    // Sort attempts by timestamp (newest first)
                                    attempts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                                    
                                    if (!latestAttemptsMap[quizType] || 
                                        (attempts[0].timestamp > latestAttemptsMap[quizType].timestamp)) {
                                        latestAttemptsMap[quizType] = attempts[0];
                                    }
                                }
                            }
                        });
                    }
                    
                    // Generate HTML for quiz reports
                    if (Object.keys(latestAttempts).length === 0) {
                        reportContainer.innerHTML = '<div class="no-data">No quiz results found. If you have taken quizzes recently, try refreshing the page.</div>';
                        return;
                    }
                    
                    // Log found data for debugging
                    console.log(`Found ${Object.keys(latestAttempts).length} quiz types with data:`, Object.keys(latestAttempts));
                    
                    // Generate CVI Risk Assessment
                    const cviRiskHTML = generateCVIRiskReport(latestAttempts);
                
                // Add data analysis trigger section with adaptive options
                const dataAnalysisTrigger = `
                    <div class="data-analysis-trigger">
                        <h3>🔬 Advanced Data Analysis & Adaptive Standards</h3>
                        <p>Analyze quiz performance data and create adaptive, cross-user standards for optimal CVI risk assessment</p>
                        
                        <div class="analysis-options">
                            <div class="analysis-option">
                                <h4>📊 Quiz-Specific Analysis</h4>
                                <p>Compare current thresholds against actual data for each quiz type</p>
                                <button onclick="analyzeQuizDataForThresholds()" class="btn-secondary">📊 Run Quiz Analysis</button>
                            </div>
                            
                            <div class="analysis-option recommended">
                                <h4>🤖 Adaptive Standards (Recommended)</h4>
                                <p>Create persistent, cross-user standards that learn and improve over time</p>
                                <button onclick="analyzeAndUpdateAdaptiveStandards()" class="btn-primary">🤖 Generate Adaptive Standards</button>
                            </div>
                        </div>
                        
                        <div class="existing-standards" id="existing-standards-info" style="display: none;">
                            <h4>⚙️ Existing Adaptive Standards</h4>
                            <p id="standards-info">Loading...</p>
                            <button onclick="applyAdaptiveStandards()" class="btn-primary">✅ Apply Existing Standards</button>
                        </div>
                    </div>
                `;
                
                let reportsHTML = cviRiskHTML + dataAnalysisTrigger;
                
                // Initialize adaptive standards on page load
                initializeAdaptiveThresholds().then(() => {
                    updateExistingStandardsDisplay();
                });
                    
                    // Sort quiz types alphabetically by display name
                    const sortedQuizTypes = Object.keys(latestAttempts).sort((a, b) => {
                        const nameA = quizNames[a] || a;
                        const nameB = quizNames[b] || b;
                        return nameA.localeCompare(nameB);
                    });
                    
                    sortedQuizTypes.forEach(quizType => {
                        const attempt = latestAttempts[quizType];
                        const displayName = quizNames[quizType] || quizType;
                        const date = formatDate(attempt.timestamp);
                        const score = attempt.score || 0;
                        const scoreClass = getScoreClass(score);
                        const cviRisk = calculateCVIRisk(quizType, attempt);
                        
                        // Calculate time in seconds for display
                        const timeSpent = Math.round((attempt.timeSpent || 0) / 1000); // in seconds
                        
                        // Create quiz report card with expandable details
                        reportsHTML += `
                            <div class="quiz-report" data-quiz-type="${quizType}">
                                <div class="quiz-report-header" onclick="toggleQuizDetails('${quizType}')">
                                    <div>
                                        <div class="quiz-title">
                                            ${displayName}
                                            <span class="cvi-risk-badge cvi-risk-${cviRisk}" style="margin-left: 10px; font-size: 10px;">${cviRisk}</span>
                                        </div>
                                        <div class="quiz-date">Latest attempt: ${date}</div>
                                    </div>
                                    <div id="toggle-icon-${quizType}">+</div>
                                </div>
                                
                                <div id="quiz-details-${quizType}" class="quiz-details">
                                    <div class="progress-container">
                                        <div class="progress-bar" style="width: ${score}%"></div>
                                    </div>
                                    
                                    <div class="raw-data">
                                        <table class="stats-table">
                                            <tbody>
                                                ${Object.entries(attempt).map(([key, value]) => {
                                                    // Skip timestamp as it's already shown in the date
                                                    if (key === 'timestamp') return '';
                                                    
                                                    // Format timeSpent as seconds
                                                    if (key === 'timeSpent') {
                                                        value = Math.round(value / 1000) + 's';
                                                    }
                                                    
                                                    return `<tr>
                                                        <td>${key}</td>
                                                        <td>${value}</td>
                                                    </tr>`;
                                                }).join('')}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    reportContainer.innerHTML = reportsHTML;
                    
                } catch (error) {
                    console.error('Error loading quiz reports:', error);
                    const reportContainer = document.getElementById('report-container');
                    reportContainer.innerHTML = '<div class="no-data">Error loading quiz reports. Please try again later.</div>';
                }
            }
            
            // Initialize profile icon
            async function initializeProfileIcon() {
                const user = auth.currentUser;
                if (!user && !isPatientQuiz) return;
                
                try {
                    let userDisplayName = 'User';
                    let initial = 'U';
                    let profile;
                    
                    if (isPatientQuiz) {
                        // Doctor viewing patient
                        const patientSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/profile`).once('value');
                        profile = patientSnapshot.val();
                        
                        if (profile && profile.name) {
                            userDisplayName = profile.name;
                            initial = profile.name.charAt(0).toUpperCase();
                        }
                        
                        // Show patient indicator
                        document.getElementById('patient-indicator-container').style.display = 'block';
                    } else {
                        // Regular user
                        const userSnapshot = await database.ref(`users/${user.uid}/profile`).once('value');
                        profile = userSnapshot.val();
                        
                        if (profile && profile.name) {
                            userDisplayName = profile.name;
                            initial = profile.name.charAt(0).toUpperCase();
                        } else if (user.email) {
                            userDisplayName = user.email.split('@')[0];
                            initial = user.email.charAt(0).toUpperCase();
                        }
                    }
                    
                    // Set profile icon and user name
                    const profileIcon = document.getElementById('profileIcon');
                    if (profileIcon) {
                        profileIcon.textContent = initial;
                    }
                    
                    const userName = document.getElementById('userName');
                    if (userName) {
                        userName.textContent = userDisplayName;
                    }
                } catch (error) {
                    console.error('Error in profile initialization:', error);
                    
                    const profileIcon = document.getElementById('profileIcon');
                    if (profileIcon) {
                        profileIcon.textContent = user ? (user.email ? user.email.charAt(0).toUpperCase() : 'U') : 'U';
                    }
                    
                    const userName = document.getElementById('userName');
                    if (userName) {
                        userName.textContent = user ? (user.email ? user.email.split('@')[0] : 'User') : 'User';
                    }
                }
            }
            
            function editProfile() {
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                if (currentPatientId) {
                    // If accessing as a patient, go to patient profile page
                    window.location.href = 'patient_profile.html';
                } else {
                    // Regular user/doctor profile
                    window.location.href = 'profile.html';
                }
            }
            
            function logout() {
                const currentPatientId = sessionStorage.getItem('currentPatientId');
                if (currentPatientId) {
                    // If accessing as a patient, clear session and return to patients.html
                    sessionStorage.removeItem('currentPatientId');
                    sessionStorage.removeItem('doctorId');
                    window.location.href = 'patients.html';
                } else {
                    // Regular logout
                    auth.signOut()
                        .then(() => {
                            sessionStorage.clear();
                            window.location.href = 'login.html';
                        })
                        .catch(error => console.error('Error logging out:', error));
                }
            }
            
            // Try to load Firestore profiles to complement database data
            async function loadFirestoreUserProfiles() {
                try {
                    const userProfiles = new Map();
                    const profilesSnapshot = await firestore.collection('userProfiles').get();
                    profilesSnapshot.docs.forEach(doc => {
                        userProfiles.set(doc.id, doc.data());
                    });
                    console.log(`Loaded ${userProfiles.size} Firestore profiles`);
                    return userProfiles;
                } catch (error) {
                    console.warn('Error loading Firestore profiles:', error);
                    return new Map();
                }
            }

            // Auth state observer
            auth.onAuthStateChanged(async user => {
                if (user || isPatientQuiz) {
                    await initializeProfileIcon();
                    // Load Firestore profiles in the background
                    loadFirestoreUserProfiles().then(() => {
                        // Once profiles are loaded, load quiz reports
                        loadQuizReports();
                    });
                } else {
                    window.location.href = 'login.html';
                }
            });
        </script>
    </div>
</body>
</html>
