<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Perception - Percepto</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-y: auto;
            margin: 0;
            flex-direction: column;
        }

        #game-container {
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.1);
            width: 450px;
            max-width: 95vw;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .profile-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #2196F3;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            transition: background-color 0.3s;
            font-size: 18px;
        }
        
        .profile-icon:hover {
            background-color: #1976D2;
        }

        .patient-indicator {
            display: inline-block;
            background-color: #e9f5e9;
            color: #4CAF50;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }

        button {
            padding: 10px 15px;
            margin: 10px;
            border: none;
            background-color: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
        }

        button:hover {
            background-color: #45a049;
        }

        #game-canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            touch-action: none;
            max-width: 100%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .score-container {
            margin-top: 15px;
            font-size: 18px;
            font-weight: bold;
        }

        #timer {
            display: inline-block;
            font-size: 1.2rem;
            margin: 10px 0;
            color: #666;
        }

        #level-indicator {
            color: #2196F3;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #instruction {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9f5ff;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        #result-container {
            display: none;
            margin-top: 20px;
        }

        #report-container {
            margin-top: 40px;
            width: 80%;
            max-width: 600px;
            display: none;  
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #report-container h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        #report-container ul {
            list-style-type: none;
            padding: 0;
            width: 100%;
        }

        .attempt-item {
            background-color: #f9f9f9;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .attempt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .attempt-date {
            font-weight: 500;
            color: #555;
        }

        .attempt-score {
            font-weight: bold;
            color: #4CAF50;
        }

        .attempt-details {
            display: none;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
        }

        .attempt-detail-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .detail-label {
            font-weight: bold;
            color: #555;
        }

        .toggle-details-btn {
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .toggle-details-btn:hover {
            background-color: #45a049;
        }

        @media (max-width: 600px) {
            #game-container {
                width: 95%;
                padding: 15px 10px;
            }

            h1 {
                font-size: 1.5rem;
            }

            #game-canvas {
                width: 95%;
                height: auto;
            }

            .header {
                flex-direction: column;
                gap: 10px;
            }

            .profile-icon {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            button {
                padding: 8px 12px;
                font-size: 14px;
                margin: 5px;
            }

            .attempt-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="header">
            <h1>Motion Perception</h1>
            <div class="profile-icon" id="profile-icon" title="Back to Home" onclick="window.location.href='index.html'"></div>
            <div class="patient-indicator" id="patient-indicator" style="display: none;">Patient</div>
        </div>
        
        <div id="level-indicator">Level: <span id="current-level">1</span>/3</div>
        
        <div id="instruction">
            Guide the character along the path to reach the goal. Stay on the highlighted path for the best score.
        </div>
        
        <div id="timer">Time: 0s</div>
        
        <canvas id="game-canvas" width="400" height="300"></canvas>
        
        <div class="score-container">
            Score: <span id="score">0</span>
        </div>
        
        <div class="controls">
            <button id="start-btn">Start Game</button>
            <button id="next-level-btn" style="display: none;">Next Level</button>
            <button id="reset-btn" style="display: none;">Try Again</button>
        </div>
        
        <div id="result-container">
            <h2>Game Results</h2>
            <ul>
                <li><strong>Total Time:</strong> <span id="total-time">0</span> seconds</li>
                <li><strong>Score:</strong> <span id="final-score">0</span></li>
                <li><strong>Accuracy:</strong> <span id="accuracy">0</span>%</li>
                <li><strong>Path Deviations:</strong> <span id="deviations">0</span></li>
                <li><strong>Movement Consistency:</strong> <span id="consistency-score">0</span>%</li>
                <li><strong>Hand Steadiness:</strong> <span id="hand-steadiness">0</span>/10 <small>(higher is better)</small></li>
                <li><strong>Reaction Time:</strong> <span id="reaction-time">0</span>ms</li>
            </ul>
            <a href="index.html" style="text-decoration: none;"><button>Return Home</button></a>
        </div>
    </div>
    
    <div id="report-container">
        <h2>All Quiz Attempts</h2>
        <ul id="report-list"></ul>
        <button id="clear-report" onclick="clearReport()">Clear Report</button>
    </div>

    <!-- Firebase Scripts -->  
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDFENL5Z_2Cewh4p6zp_BZtxL9n0di-9u8",
            authDomain: "projeccvi.firebaseapp.com",
            projectId: "projeccvi",
            storageBucket: "projeccvi.appspot.com",
            messagingSenderId: "279067566247",
            appId: "1:279067566247:web:9cf00f7bf1ea3549fabb82"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();
        
        // Get quiz context from session storage
        const currentPatientId = sessionStorage.getItem('currentPatientId');
        const doctorId = sessionStorage.getItem('doctorId');
        const isPatientQuiz = !!(currentPatientId && doctorId);
        
        console.log('Quiz context in Motion Perception:', { 
            isPatientQuiz, 
            currentPatientId: currentPatientId || 'none',
            doctorId: doctorId || 'none'
        });

        // Game canvas and context
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Game state variables
        let gameRunning = false;
        let gameStarted = false;
        let currentLevel = 1;
        let score = 0;
        let totalDeviations = 0;
        let accuracy = 100;
        let startTime = null;
        let elapsedTime = 0;
        let timerInterval = null;
        let firstInteractionTime = null;
        let totalInteractions = 0;
        
        // Motion analysis metrics
        let consistencyScore = 100; // Tracks steadiness of motion
        let handTremorScore = 0;    // Measures micro deviations
        let velocityData = [];      // For tracking motion velocity
        let previousPositions = []; // Last 10 positions for tremor analysis
        let positionTimestamps = []; // Timestamps of positions for velocity calculation
        
        // Character position tracking
        let characterPosition = { x: 0, y: 0 };
        let characterSpeed = 2; // Reduced movement speed
        let targetPosition = { x: 0, y: 0 };
        let isDragging = false;
        let isOnPath = true;
        let pathDeviation = 0;
        let goalReached = false;
        
        // Path variables
        let currentPath = [];
        let pathWidth = 20; // Width of acceptable path area
        
        // Touch tracking
        let lastTouchX = 0;
        let lastTouchY = 0;
        
        // Images
        const characterImg = new Image();
        characterImg.src = 'images/VC/animal/cat1.png';
        const goalImg = new Image();
        goalImg.src = 'images/VC/animal/cat.png';

        // Draw character at specified position
        function drawCharacter(x, y) {
            ctx.drawImage(characterImg, x - 25, y - 25, 50, 50);
        }

        // Draw goal at specified position
        function drawGoal(x, y) {
            ctx.drawImage(goalImg, x - 25, y - 25, 50, 50);
        }

        // Draw the current path
        function drawPath() {
            if (currentPath.length < 2) return;
            
            // Draw path base (wider background)
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.strokeStyle = '#aaaaaa';
            ctx.lineWidth = pathWidth;
            ctx.stroke();
            
            // Draw highlighted path (center)
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) {
                ctx.lineTo(currentPath[i].x, currentPath[i].y);
            }
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = pathWidth / 2;
            ctx.stroke();
            
            // Draw start and goal
            drawGoal(currentPath[currentPath.length - 1].x, currentPath[currentPath.length - 1].y);
        }

        // Clear the canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Render the game state
        function render() {
            clearCanvas();
            drawPath();
            drawCharacter(characterPosition.x, characterPosition.y);
            
            // Draw path status indicator
            if (!isOnPath && gameRunning) {
                ctx.beginPath();
                ctx.arc(characterPosition.x, characterPosition.y, 30, 0, Math.PI * 2);
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Check if goal reached
            if (gameRunning && !goalReached) {
                const distToGoal = distanceToPoint(
                    characterPosition.x, 
                    characterPosition.y, 
                    currentPath[currentPath.length - 1].x, 
                    currentPath[currentPath.length - 1].y
                );
                
                if (distToGoal < 30) {
                    // Check if at least 90% of path points were visited
                    const visitedCount = visitedPathPoints.filter(visited => visited).length;
                    const completionPercent = (visitedCount / visitedPathPoints.length) * 100;
                    
                    if (completionPercent >= 90) {
                        goalReached = true;
                        completeLevel();
                    } else {
                        // Alert user that they need to follow the entire path
                        const feedback = document.createElement('div');
                        feedback.textContent = 'You must follow the entire path! Only ' + 
                                              Math.floor(completionPercent) + '% completed.';
                        feedback.style.position = 'absolute';
                        feedback.style.top = '50%';
                        feedback.style.left = '50%';
                        feedback.style.transform = 'translate(-50%, -50%)';
                        feedback.style.backgroundColor = 'rgba(255, 0, 0, 0.7)';
                        feedback.style.color = 'white';
                        feedback.style.padding = '10px 20px';
                        feedback.style.borderRadius = '5px';
                        feedback.style.zIndex = '100';
                        document.getElementById('game-container').appendChild(feedback);
                        
                        // Remove feedback after 2 seconds
                        setTimeout(() => {
                            feedback.remove();
                        }, 2000);
                    }
                }
            }
        }

        // Profile icon initialization
        function initProfileIcon() {
            const profileIcon = document.getElementById('profile-icon');
            const patientIndicator = document.getElementById('patient-indicator');
            const userNameElement = document.getElementById('user-name');
            
            auth.onAuthStateChanged(async (user) => {
                if (user) {
                    try {
                        // Check if this is a patient quiz
                        if (isPatientQuiz) {
                            console.log('Doctor viewing patient quiz');
                            // Get patient profile from doctor's patients list
                            const patientSnapshot = await database.ref(`doctors/${doctorId}/patients/${currentPatientId}/profile`).once('value');
                            const profile = patientSnapshot.val() || {};
                            
                            if (userNameElement) userNameElement.textContent = profile.name || 'Patient';
                            const initial = (profile.name || 'P').charAt(0).toUpperCase();
                            profileIcon.textContent = initial;
                            patientIndicator.style.display = 'inline-block';
                        } else {
                            // Regular user
                            // Get user profile data
                            const userSnap = await database.ref(`users/${user.uid}/profile`).once('value');
                            const profile = userSnap.val() || {};
                            
                            if (userNameElement) userNameElement.textContent = profile.name || user.displayName || user.email || 'User';
                            const initial = (profile.name || user.displayName || user.email || 'U').charAt(0).toUpperCase();
                            profileIcon.textContent = initial;
                            patientIndicator.style.display = 'none';
                        }
                    } catch (error) {
                        console.error('Error in profile initialization:', error);
                        profileIcon.textContent = 'U';
                    }
                } else {
                    console.log('No user is signed in');
                    profileIcon.textContent = 'G'; // Guest User
                    if (userNameElement) userNameElement.textContent = 'Guest';
                }
            });
        }

        // Generate a randomized path for the current level
        function generateRandomPath(level) {
            const paths = [
                // Level 1: Simple straight line
                [{ x: 50, y: 150 }, { x: 350, y: 150 }],
                
                // Level 2: Slight curve
                [{ x: 50, y: 150 }, { x: 150, y: 100 }, { x: 250, y: 200 }, { x: 350, y: 150 }],
                
                // Level 3: Zigzag (final level)
                [{ x: 50, y: 50 }, { x: 150, y: 150 }, { x: 250, y: 50 }, { x: 350, y: 150 }]
            ];
            
            // Select path based on level (with fallback to last path if level is too high)
            const pathIndex = Math.min(level - 1, paths.length - 1);
            return paths[pathIndex];
        }

        // Calculate distance between two points
        function distanceToPoint(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Array to track visited path points
        let visitedPathPoints = [];
        let pathPoints = [];
        let nearestPointIndex = 0;
        
        // Generate interpolated points along the path for more precise tracking
        function createDetailedPath(path) {
            if (!path || path.length < 2) return [];
            
            pathPoints = [];
            visitedPathPoints = [];
            nearestPointIndex = 0;
            
            // For each segment, generate points along it
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                // Add the starting point
                pathPoints.push(p1);
                visitedPathPoints.push(false);
                
                // Number of interpolation points based on segment length
                const distance = distanceToPoint(p1.x, p1.y, p2.x, p2.y);
                const numPoints = Math.max(5, Math.floor(distance / 10));
                
                // Add interpolated points
                for (let j = 1; j < numPoints; j++) {
                    const ratio = j / numPoints;
                    const x = p1.x + (p2.x - p1.x) * ratio;
                    const y = p1.y + (p2.y - p1.y) * ratio;
                    pathPoints.push({x, y});
                    visitedPathPoints.push(false);
                }
            }
            
            // Add the final point
            pathPoints.push(path[path.length - 1]);
            visitedPathPoints.push(false);
            
            return pathPoints;
        }
        
        // Find the nearest point on the path to the given coordinates
        function findNearestPointOnPath(x, y) {
            if (pathPoints.length < 2) return {point: null, index: 0, distance: Infinity};
            
            let minDist = Infinity;
            let nearestIndex = 0;
            
            // Allow searching both forward and backward along the entire path
            for (let i = 0; i < pathPoints.length; i++) {
                const dist = distanceToPoint(x, y, pathPoints[i].x, pathPoints[i].y);
                if (dist < minDist) {
                    minDist = dist;
                    nearestIndex = i;
                }
            }
            
            // Mark points as visited - mark this point and all previous points
            for (let i = 0; i <= nearestIndex; i++) {
                visitedPathPoints[i] = true;
            }
            
            // Update the global nearest point index
            nearestPointIndex = nearestIndex;
            
            return {
                point: pathPoints[nearestIndex],
                index: nearestIndex,
                distance: minDist
            };
        }

        // Find the nearest point on a line segment
        function nearestPointOnSegment(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            return { x: xx, y: yy };
        }

        // Start a new level
        function startLevel(level) {
            document.getElementById('current-level').textContent = level;
            
            // Reset level variables
            goalReached = false;
            isOnPath = true;
            pathDeviation = 0;
            elapsedTime = 0;
            startTime = Date.now();
            
            // Generate new path for this level
            currentPath = generateRandomPath(level);
            
            // Generate detailed path points and reset tracking
            pathPoints = createDetailedPath(currentPath);
            visitedPathPoints = Array(pathPoints.length).fill(false);
            nearestPointIndex = 0; // Start at the beginning
            
            // Init character at the start of the path
            characterPosition = { x: pathPoints[0].x, y: pathPoints[0].y };
            
            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('level-indicator').style.display = 'block';
            document.getElementById('instruction').style.display = 'block';
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('next-level-btn').style.display = 'none';
            document.getElementById('reset-btn').style.display = 'inline-block';
            document.getElementById('result-container').style.display = 'none';
            
            // Hide report container during gameplay
            document.getElementById('report-container').style.display = 'none';
            
            // Reset motion analysis metrics
            previousPositions = [];
            positionTimestamps = [];
            velocityData = [];
            handTremorScore = 0;
            consistencyScore = 100;
            totalInteractions = 0;
            firstInteractionTime = null;
            accuracy = 100;
            
            // Start game
            gameRunning = true;
            
            // Start timer
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 100);
            
            render();
        }

        // Complete the current level
        function completeLevel() {
            gameRunning = false;
            clearInterval(timerInterval);
            
            // Calculate final metrics for the level
            calculateFinalMetrics();
            
            // Update score based on level, time, accuracy, consistency and tremor
            const levelBonus = currentLevel * 50;
            const timeBonus = Math.max(0, 300 - elapsedTime);
            const accuracyBonus = Math.floor(accuracy);
            const consistencyBonus = Math.floor(consistencyScore / 2);
            const tremorPenalty = Math.min(50, handTremorScore * 5); // Higher tremor = lower score
            
            const levelScore = levelBonus + timeBonus + accuracyBonus + consistencyBonus - tremorPenalty;
            score += levelScore;
            
            // Update UI
            document.getElementById('score').textContent = score;
            
            // Check if there are more levels
            if (currentLevel < 3) {
                document.getElementById('next-level-btn').style.display = 'inline-block';
                document.getElementById('reset-btn').style.display = 'none';
            } else {
                // Game complete after 3 levels (like VDT1.html)
                showResults();
            }
        }
        
        // Save results to Firebase
        function saveResults() {
            auth.onAuthStateChanged(user => {
                if (user) {
                    const uid = user.uid;
                    const timestamp = Date.now();
                    let refPath;
                    
                    if (isPatientQuiz) {
                        // This is a doctor administering a quiz to a patient
                        refPath = `doctors/${doctorId}/patients/${currentPatientId}/quiz/motion/${timestamp}`;
                    } else {
                        // Regular user taking the quiz
                        refPath = `users/${uid}/quiz/motion/${timestamp}`;
                    }
                    
                    const resultData = {
                        score: score,
                        totalTime: elapsedTime,
                        accuracy: Math.floor(accuracy),
                        deviations: totalDeviations,
                        totalLevels: currentLevel,
                        firstInteractionTime: firstInteractionTime || 0,
                        totalInteractions: totalInteractions,
                        consistencyScore: Math.floor(consistencyScore),
                        handSteadiness: (10 - handTremorScore).toFixed(1),
                        timestamp: timestamp,
                        date: new Date().toISOString()
                    };
                    
                    database.ref(refPath).set(resultData).then(() => {
                        console.log('Results saved to Firebase');
                    }).catch(error => {
                        console.error('Error saving results:', error);
                    });
                }
            });
        }

        // Calculate final metrics for the report
        function calculateFinalMetrics() {
            // Make sure elapsed time is properly calculated
            if (startTime && gameRunning) {
                elapsedTime = (Date.now() - startTime) / 1000; // Convert to seconds
            }
            
            // Normalize accuracy to ensure it's within 0-100%
            accuracy = Math.max(0, Math.min(100, accuracy));
            
            // Ensure consistency score is within 0-100%
            consistencyScore = Math.max(0, Math.min(100, consistencyScore));
            
            // Normalize hand tremor score to 0-10 scale
            handTremorScore = Math.max(0, Math.min(10, handTremorScore));
        }
        
        // Show final results
        function showResults() {
            // Ensure metrics are properly calculated one last time
            calculateFinalMetrics();
            
            document.getElementById('final-score').textContent = score;
            document.getElementById('total-time').textContent = Math.round(elapsedTime);
            document.getElementById('accuracy').textContent = Math.floor(accuracy) + '%';
            document.getElementById('deviations').textContent = totalDeviations;
            document.getElementById('consistency-score').textContent = Math.floor(consistencyScore) + '%';
            document.getElementById('hand-steadiness').textContent = (10 - handTremorScore).toFixed(1) + '/10';
            document.getElementById('reaction-time').textContent = firstInteractionTime || 0;
            
            document.getElementById('result-container').style.display = 'block';
            document.getElementById('next-level-btn').style.display = 'none';
            document.getElementById('reset-btn').style.display = 'none';
            
            // Show report container after game completion
            document.getElementById('report-container').style.display = 'flex';
            
            // Save results to Firebase
            saveResults();
            
            // Load previous attempts
            loadPreviousAttempts();
        }

        // Event listeners for game controls
        document.getElementById('start-btn').addEventListener('click', function() {
            startLevel(currentLevel);
        });
        
        document.getElementById('next-level-btn').addEventListener('click', function() {
            currentLevel++;
            startLevel(currentLevel);
        });
        
        document.getElementById('reset-btn').addEventListener('click', function() {
            gameRunning = false;
            clearInterval(timerInterval);
            startLevel(currentLevel);
        });
        
        // Mouse events for character movement
        canvas.addEventListener('mousedown', function(e) {
            if (!gameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            isDragging = true;
            
            // Record first meaningful interaction time
            if (firstInteractionTime === null) {
                firstInteractionTime = Date.now() - startTime;
            }
            
            totalInteractions++;
            
            handleInteraction(x, y);
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (!gameRunning || !isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            handleInteraction(x, y);
        });
        
        canvas.addEventListener('mouseup', function() {
            isDragging = false;
        });
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', function(e) {
            if (!gameRunning) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            lastTouchX = x;
            lastTouchY = y;
            isDragging = true;
            
            // Record first meaningful interaction time
            if (firstInteractionTime === null) {
                firstInteractionTime = Date.now() - startTime;
            }
            
            totalInteractions++;
            
            handleInteraction(x, y);
        });
        
        canvas.addEventListener('touchmove', function(e) {
            if (!gameRunning || !isDragging) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            lastTouchX = x;
            lastTouchY = y;
            
            handleInteraction(x, y);
        });
        
        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            isDragging = false;
        });
        
        // Calculate consistency score and hand tremor based on recent movements
        function calculateMotionMetrics(x, y) {
            const currentTime = Date.now();
            
            // Store current position with timestamp
            previousPositions.push({x, y, time: currentTime});
            positionTimestamps.push(currentTime);
            
            // Keep only last 10 positions for analysis
            if (previousPositions.length > 10) {
                previousPositions.shift();
                positionTimestamps.shift();
            }
            
            // Need at least 3 positions for analysis
            if (previousPositions.length >= 3) {
                // Calculate velocity variation (consistency)
                const velocities = [];
                for (let i = 1; i < previousPositions.length; i++) {
                    const prev = previousPositions[i-1];
                    const curr = previousPositions[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dt = curr.time - prev.time;
                    if (dt > 0) { // Avoid division by zero
                        const velocity = Math.sqrt(dx*dx + dy*dy) / dt;
                        velocities.push(velocity);
                    }
                }
                
                // Calculate velocity variance for consistency
                if (velocities.length > 0) {
                    const avgVelocity = velocities.reduce((sum, v) => sum + v, 0) / velocities.length;
                    const velocityVariance = velocities.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocities.length;
                    
                    // Update consistency score (lower variance = higher consistency)
                    const newConsistency = 100 - Math.min(100, velocityVariance * 5000);
                    consistencyScore = (consistencyScore * 0.9) + (newConsistency * 0.1); // Smooth changes
                    
                    // Store for later analysis
                    velocityData.push(avgVelocity);
                }
                
                // Calculate micro-deviations for tremor detection
                let totalDeviation = 0;
                for (let i = 2; i < previousPositions.length; i++) {
                    const p1 = previousPositions[i-2];
                    const p2 = previousPositions[i];
                    const mid = previousPositions[i-1];
                    
                    // Calculate expected midpoint between p1 and p2
                    const expectedX = (p1.x + p2.x) / 2;
                    const expectedY = (p1.y + p2.y) / 2;
                    
                    // Calculate deviation of actual midpoint from expected
                    const deviationX = mid.x - expectedX;
                    const deviationY = mid.y - expectedY;
                    const microDeviation = Math.sqrt(deviationX*deviationX + deviationY*deviationY);
                    
                    totalDeviation += microDeviation;
                }
                
                // Average micro-deviation (higher = more tremor)
                const avgMicroDeviation = totalDeviation / (previousPositions.length - 2);
                const newTremorScore = Math.min(10, avgMicroDeviation);
                
                // Update tremor score with smoothing
                handTremorScore = (handTremorScore * 0.9) + (newTremorScore * 0.1);
            }
        }
        
        // Calculate final metrics at the end of a level
        function calculateFinalMetrics() {
            // Calculate final consistency based on all velocity data
            if (velocityData.length > 0) {
                const avgVelocity = velocityData.reduce((sum, v) => sum + v, 0) / velocityData.length;
                const velocityVariance = velocityData.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocityData.length;
                consistencyScore = Math.max(0, 100 - Math.min(100, velocityVariance * 5000));
            }
            
            // Normalize and scale tremor score for final results
            handTremorScore = Math.min(10, handTremorScore);
        }
        
        // Handle user interaction (mouse or touch)
        function handleInteraction(x, y) {
            if (goalReached) return;
            
            // Always start from the starting point if this is the first interaction
            if (totalInteractions === 0 && gameRunning) {
                characterPosition.x = pathPoints[0].x;
                characterPosition.y = pathPoints[0].y;
                render();
                totalInteractions++;
                return;
            }
            
            // Find nearest point on the path
            const pathInfo = findNearestPointOnPath(x, y);
            
            // Calculate motion metrics regardless of path following
            calculateMotionMetrics(x, y);
            
            // Track the total interactions
            totalInteractions++;
            
            // Record first interaction time if not already set
            if (firstInteractionTime === null && gameRunning) {
                firstInteractionTime = Date.now() - startTime;
            }
            
            if (pathInfo && pathInfo.distance <= pathWidth / 2) {
                // User is on the path - enforce strict path following
                // The closer to the center of the path, the better
                const pathFidelity = 1 - (pathInfo.distance / (pathWidth / 2)); // 1 = perfect center, 0 = edge
                
                // Move character to the path point with reduced speed (smooth movement)
                const moveSpeed = 0.6; // Reduced from 1.0 for slower movement
                characterPosition.x = characterPosition.x + (pathInfo.point.x - characterPosition.x) * moveSpeed;
                characterPosition.y = characterPosition.y + (pathInfo.point.y - characterPosition.y) * moveSpeed;
                
                isOnPath = true;
                
                // Reward for staying on path
                const accuracyBonus = pathFidelity * 0.1; // Reduced bonus for smoother experience
                accuracy = Math.min(100, accuracy + accuracyBonus);
                score += Math.floor(pathFidelity * 1); // Reduced score bonus
                document.getElementById('score').textContent = score;
            } else {
                // User is off the path - penalty
                isOnPath = false;
                pathDeviation++;
                totalDeviations++;
                
                // Force character back to path if too far off
                if (pathInfo && pathInfo.distance > pathWidth * 2) {
                    // Snap back to path with smooth movement
                    const moveSpeed = 0.5; // Slower than on-path movement
                    characterPosition.x = characterPosition.x + (pathInfo.point.x - characterPosition.x) * moveSpeed;
                    characterPosition.y = characterPosition.y + (pathInfo.point.y - characterPosition.y) * moveSpeed;
                    
                    // Penalty for going far off path
                    const penalty = Math.floor(pathInfo.distance / 5); // Reduced penalty
                    score = Math.max(0, score - penalty);
                    document.getElementById('score').textContent = score;
                } else {
                    // Allow slight deviation but with penalty
                    const moveSpeed = 0.6; // Controlled movement
                    characterPosition.x = characterPosition.x + (x - characterPosition.x) * moveSpeed;
                    characterPosition.y = characterPosition.y + (y - characterPosition.y) * moveSpeed;
                    
                    // Smaller penalty for minor deviation
                    score = Math.max(0, score - 1);
                    document.getElementById('score').textContent = score;
                }
                
                // Update accuracy with penalty for being off path
                const accuracyPenalty = Math.min(3, pathInfo ? pathInfo.distance / 15 : 3); // Reduced penalty
                accuracy = Math.max(0, accuracy - accuracyPenalty);
            }
            
            render();
        }
        
        // Clear report function
        async function clearReport() {
            try {
                // Get current user
                const user = auth.currentUser;
                if (!user) {
                    alert('You must be signed in to clear reports');
                    return;
                }
                
                // Determine the correct path
                let path;
                if (isPatientQuiz) {
                    path = `doctors/${doctorId}/patients/${currentPatientId}/quiz/motion`;
                } else {
                    path = `users/${user.uid}/quiz/motion`;
                }
                
                console.log(`Removing all quiz results from path: ${path}`);
                
                // Remove all data at the specified path
                await database.ref(path).remove();
                
                // Clear the list in the UI
                document.getElementById('report-list').innerHTML = '';
                
                alert('All quiz reports have been cleared successfully.');
                
            } catch (error) {
                console.error('Error clearing report:', error);
                alert('Failed to clear the report: ' + error.message);
            }
        }
        
        // Load previous attempts
        function loadPreviousAttempts() {
            const reportList = document.getElementById('report-list');
            reportList.innerHTML = '';
            
            auth.onAuthStateChanged(async user => {
                if (user) {
                    const uid = user.uid;
                    let refPath;
                    
                    if (isPatientQuiz) {
                        refPath = `doctors/${doctorId}/patients/${currentPatientId}/quiz/motion`;
                    } else {
                        refPath = `users/${uid}/quiz/motion`;
                    }
                    
                    database.ref(refPath).orderByChild('timestamp').limitToLast(10).once('value', snapshot => {
                        const attempts = [];
                        snapshot.forEach(childSnapshot => {
                            attempts.push({
                                key: childSnapshot.key,
                                ...childSnapshot.val()
                            });
                        });
                        
                        // Sort by timestamp descending (newest first)
                        attempts.sort((a, b) => b.timestamp - a.timestamp);
                        
                        if (attempts.length === 0) {
                            reportList.innerHTML = '<p>No previous attempts found.</p>';
                            return;
                        }
                        
                        attempts.forEach(attempt => {
                            const date = new Date(attempt.timestamp);
                            const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                            
                            const attemptItem = document.createElement('li');
                            attemptItem.className = 'attempt-item';
                            
                            const header = document.createElement('div');
                            header.className = 'attempt-header';
                            
                            const dateSpan = document.createElement('span');
                            dateSpan.className = 'attempt-date';
                            dateSpan.textContent = dateStr;
                            
                            const scoreSpan = document.createElement('span');
                            scoreSpan.className = 'attempt-score';
                            scoreSpan.textContent = `Score: ${attempt.score}`;
                            
                            header.appendChild(dateSpan);
                            header.appendChild(scoreSpan);
                            
                            const toggleBtn = document.createElement('button');
                            toggleBtn.className = 'toggle-details-btn';
                            toggleBtn.textContent = 'Show Details';
                            
                            const details = document.createElement('div');
                            details.className = 'attempt-details';
                            details.innerHTML = `
                                <div>Time: ${attempt.totalTime ? Math.round(attempt.totalTime) : '0'} seconds</div>
                                <div>Accuracy: ${attempt.accuracy ? Math.floor(attempt.accuracy) : '0'}%</div>
                                <div>Path Deviations: ${attempt.deviations || 0}</div>
                                <div>Consistency: ${attempt.consistencyScore ? Math.floor(attempt.consistencyScore) : '0'}%</div>
                                <div>Hand Steadiness: ${attempt.handSteadiness || '0'}/10</div>
                                <div>Reaction Time: ${attempt.firstInteractionTime || 0}ms</div>
                            `;
                            
                            toggleBtn.addEventListener('click', function() {
                                if (details.style.display === 'grid') {
                                    details.style.display = 'none';
                                    toggleBtn.textContent = 'Show Details';
                                } else {
                                    details.style.display = 'grid';
                                    toggleBtn.textContent = 'Hide Details';
                                }
                            });
                            
                            attemptItem.appendChild(header);
                            attemptItem.appendChild(toggleBtn);
                            attemptItem.appendChild(details);
                            reportList.appendChild(attemptItem);
                        });
                    });
                    
                    // Show report container
                    document.getElementById('report-container').style.display = 'flex';
                }
            });
        }
        
        // Initialize the game
        function init() {
            initProfileIcon();
            render();
        }
        
        // Start when everything is loaded
        window.onload = init;
    </script>
</body>
</html>